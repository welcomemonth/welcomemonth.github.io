---
layout:     post
title:      C语言练习题
subtitle:   C
date:       2024-05-17
author:     zhengyu
header-img: img/program.png
catalog: true
tags:
    - program
---

# 5/17号

## 1、主函数main也有参数：int main(int argc,char **argv)

## 2、下面关于delete描述错误的是（）

> A 他必须用于new返回的指针 <br>
> B 使用他删除对象时要调用[析构函数](#析构函数) <br>
> C 对一个指针可以使用多次该运算符 <br>
> D 指针名前只有一对方括号符号，不管所删除数组的维数
```text
答案：C，不能对一个指针进行多次delete，对一个指针delete之后，它所指向的那片内存已经被回收，可能会分配用于其他数据，如果再次delete则会导致数据丢失。
delete用于释放new的创建的内存，delete[] 用于释放new创建的数组内存。
使用delete释放的对象内存时会调用对象的（隐士调用）析构函数。
```

## 4、在32位平台上

```
struct {
	unsigned char a;
    int b;
    short c
} s;
```

请问s的起始地址下面说法正确的是（）

> 答案：四字节对齐

```
struct STUDENT
{
    char a;
    char b;
    char c;
    char d;
    char e;
    int f;
}data;
```



![image-20240517205651429](/img/字节对齐.png)

## 5、在64位机器上sizeof(a) sizeof(b)大小分别是（）

```
char a[10];
char *b = (char*)malloc(10*sizeof(char));
```

> 答案： 64位系统中，指针占8个字节，32位系统中，指针占4个字节。 
>
>   a是一个字符数组，大小为10*sizeof(char)，占10字节。

## 6、下列运算符中优先级最高的是（ ）

> A <  
>
> B +  
>
> C &&
>
> D !=

> 答案：B
> <是6级, +是4级, &&是11级, !=是7级 所以加号的优先级最高。
>
> ！ > 算术运算符 > 关系运算符 > && > || > 赋值运算符
>
> 算术运算符： +  -  *  /  %  ^  ！ ···
> 关系运算符(6个)： ==  !=  >  >=  <  <=
> 赋值运算符： =  +=  -=  *=  /=  %= ···
> 逻辑运算符：&&  ||
>
> 淡云一笔，鞍落三服 
>
> (单目)(算术)(移位)(比较),(按位)(逻辑)(三目)(赋值) 
>
> 后缀自增（`++`）和后缀自减（`--`）运算符的优先级高于前缀自增（`++`）、前缀自减（`--`）、解引用（`*`）、取地址（`&`）、取负（`-`）、取反（`~`）等运算符。 

| 优先级 | 运算符                              | 结合性   | 名称 |
| ------ | ----------------------------------- | -------- | ---- |
| 1      | `() [] -> .`                        | 从左到右 |      |
| 2      | `++ -- + - ! ~ & * (type) sizeof`   | 从右到左 |      |
| 3      | `* / %`                             | 从左到右 |      |
| 4      | `+ -`                               | 从左到右 |      |
| 5      | `<< >>`                             | 从左到右 |      |
| 6      | `< <= > >=`                         | 从左到右 |      |
| 7      | `== !=`                             | 从左到右 |      |
| 8      | `&`                                 | 从左到右 |      |
| 9      | `^`                                 | 从左到右 |      |
| 10     | `|`                                 | 从左到右 |      |
| 11     | `&&`                                | 从左到右 |      |
| 12     | `||`                                | 从左到右 |      |
| 13     | `? :`                               | 从右到左 |      |
| 14     | `= += -= *= /= %= <<= >>= &= ^= |=` | 从右到左 |      |
| 15     | `,`                                 | 从左到右 |      |

![img](https://uploadfiles.nowcoder.com/images/20200824/243827773_1598264387617_EF60E972A84D8C08A55321DDC816FCD8) 



## 7、以下程序的运行结果是（）

```
#include <stdio.h> 
int main() { 
    int sum, pad,pAd; 
    sum = pad = 5; 
    pAd = ++sum, pAd++, ++pad; 
    printf("%d\n",pAd); 
}
```

> A 5  
>
> B 6
>
> C 7
>
> D 8

> 答案：C ，根据优先级计算，由于赋值表达式优先级高于逗号，所以第五行代码等价于
>
> (pAd = ++sum), pAd++, ++pad;
>
> 因此是7

## 9、在下列C代码中：如果指向非空树的根的指针作为参数传递，则DoSomething函数的返回值是（）

```
struct Celode
{
  struct Celode *lchild;
  int element;
  struct Celode *rChild;
}
  
int DoSomething(struct Celode *ptr)
{
    int value = 0;
    if (ptr != NULL)
    {
      if (ptr -> lChild != NULL)
        value = 1 + DoSomething(ptr -> lChild);
      if (ptr -> rChild != NULL)
        value = max(value, 1 + DoSomething(ptr -> rChild));
    }
    return (value);
}
```

> A 树的叶节点数
>
> B 树的节点数
>
> C 树的内部节点数
>
> D 树的高度



> 分析：如果是树的节点树就应该是加，而不是判断max，因此直接得到答案D



# 5/18号

## 1、对于C/C++语言的函数，下列叙述中正确的是（ ）

> A  函数的定义不能嵌套，但是函数调用可以嵌套
>
> B  函数的定义可以嵌套，但函数调用不能嵌套
>
> C  函数的定义和调用都不能嵌套
>
> D  函数的定义和调用都可以嵌套

> 答案：A C语言中函数定义不能嵌套，但是函数调用可以嵌套

## 2、以下程序的输出结果是（）

```
int main() {
    char ch[3][5]={"AAAA","BBB","CC"};
    printf("\"%s\"\n",ch[1]);
}
```

>A   "AAAA"
>B   "BBB"
>C   "BBBCC"
>D   "CC"

> 答案：B 
>
> 解析：ch[0]，ch[1]，ch[2]这种都是列指针（一维指针），而ch，ch+1，ch+2是行指针（数组指针），所以题目中ch[1]表示指向第二行首元素的列指针；

## 4、以下正确的函数定义形式是（）

> A double fun(int x,int y)
> B double fun (int x;int y)
> C double fun (int x,inty)；
> D double fun (intx,y)；

> 答案：A
>
> 解析：函数定义时每个形参都必须指明数据类型符，形参之间必须以逗号隔开，所
>
> 以B和D是错误的，另外，函数定义时末尾不能带分号，只有函数说明时才带分号，所以
>
> C也是错误的。故正确答案是A。

## 5、对于以下代码，char* p=new char[100];说法正确的是（）

> A p和new出来的内存都在栈上
> B p和new出来的内存都在堆上
> C p在堆上，new出来的在栈上
> D p在栈上，new出来的在堆上

> [内存布局](#内存布局)
>
> 答案：D
>
> 解析：new 出来的对象放在堆中，局部变量放在栈中。

## 6、m++ 和 ++m的区别

## 8、有以下程序，输出结果是：

```
#include <stdio. h>
int fun( int a )
{
    int b = 0;
    static int c = 3;
    a = ( c + +,b + + );
    return ( a );
}
main( )
{
    int a = 2,i,k;
    for( i = 0;i<2;i + + )
        k = fun( a + + );
    printf("%d\n",k );
}
```

> A 4
> B 0
> C 1
> D 2

> 答案：B
>
> 解析：这个题目主要分析第六行代码，由于逗号是最低优先级运算符，如果没有括号的话，    
>
> a1=(表达式1,表达式2);           a2=表达式1,表达式2;    
>
> a1是表达式2的结果，而a2是表达式1的结果
>
> 对于函数内的c来说是一个[局部静态变量](#局部静态变量)



## 9、下面程序运行结果是3，5 轻微横线处选择合适的代码

![image-20240518180146080](/img/5_18_ninth.png)

> A p++ ->n
> B (++p) ->n
> C (a+1) ->n
> D (p+1) ->n

> 答案：BCD
>
> 解析：BCD可以输出3，5 A. p++ ->n相当于p->n; p++ ，所以输出的是3，3 B.（++p）->n，p现在指向的是a数组的第二个元素，即{ 5, "def"}这个结构体元素，会输出3， 5 C.（a + 1）->n，a + 1是{ 5, "def" }元素的地址，所以会输出3,，5 D.（p + 1）->n，p + 1是增加的偏移量，即第二个元素的地址，会输出3，5

## 10.下面哪些运算符不能被重载（）

> A 三目运算符“?:”
> B 作用域运算符“::”
> C 对象成员运算符“.”
> D 指针成员运算符“->”

> 答案：ABC
>
> 解析：  不能被重载的运算符只有五个，分别是 
>
>     1.  .  （成员访问运算符） 
>     2.  *（成员指针访问运算符） 
>     3.  ::  （域运算符） 
>     4.  sizeof  （长度运算符） 
>   5. ?:    （条件运算符）
>
>  前两个运算符不能重载是为了保证访问成员的功能不被改变 ，域运算符和sizeof运算符的运算对象是类型而不是变量或者一般表达式，不具备重载的特征。



# 5/19号



## 1、下面代码段的输出为（）

```
int a = 5, b = -5;
printf("%d,%d", a%(-4), b%(-4));
```

> A  1,-1
> B  1,1
> C  -1,1
> D  -1,-1

> 答案：A
>
> 解析：对于除法/来说，（-m)/n 和 m/(-n) 等于-(m/n) 
>
> 但是对于取余%来说，(-m)%n = -(m % n)
>
> m % (-n) = m%n

## 2、一个 C 语言程序是由（）

> A 一个主程序和若干子程序组成
> B 函数组成
> C 若干过程组成
> D 若干子程序组成

> 答案：B
>
> 解析：函数是C程序的基本单位，一个C语言源程序是由一个main函数和若干其他函数组成的

## 3、运行下面这段C语言程序之后，输出在屏幕上的结果是：

```
#include<stdio.h>
void foobar(int a, int *b, int **c)
{
    int *p = &a;
    *p = 101;
    *c = b;
    b = p;
}
 
int main()
{
    int a = 1;
    int b = 2;
    int c = 3;
    int *p = &c;
    foobar(a, &b, &p);
    printf("a=%d, b=%d, c=%d, *p=%d\n", a, b, c, *p);
    return (0);
}
```

> A a=1, b=2, c=3, *p=2
> B a=101, b=2, c=3, *p=2
> C a=101, b=101, c=2, *p=3
> D a=1, b=101, c=2, *p=3

> 答案：A
>
> 分析：首先对于a来说，在foobar中是以值的形式传递的，因此无论怎么修改都不会影响main函数中的值，所以a=1不会变
>
> 函数中b传递的是主函数中b的指针，语句b = p, 其中p指向的是函数foobar内局部变量a 的地址，让传递过去的指针换了指向的数据，原来函数中的b不会由影响，如果修改为*b = *p,则原函数中的b会变化
>
> 对于c来说，他是将指向c的一个指针的地址传入，*c = b，也就是让主函数中的p指针指向了主函数中的b的地址
>
> 

## 4、对于 32 位机器，则下面代码输出结果为（）

```
#include<iostream>
#include<string>
 
using namespace std;
 
typedef struct data_ {
    int a[10];
} data_t;
 
typedef struct descriptor_ {
    data_t* ptr;
    char data[0];
} desc_t;
 
int main() {
    cout << sizeof(desc_t) << endl;
    return 0;
}
```

> A 40
> B 4
> C8 
> D 0

> 答案：B   <a name="柔性数组">柔性数组</a>
>
> 解析：首先就是对于一个32为系统指针是4字节，64位操作系统指针是8字节，然后是char data[0]是一个柔性数组，它默认不占用内存，用来指示数组可以在运行时动态分配内存。**柔性数组成员必须是结构体中的最后一个成员。 **
>
> 此外对于64位操作系统大部分int也都是四字节

struct Node      {         intsize;         char* data；      }; 

> ### 柔性数组的比较
>
> 1. **内存分配方式**：
>    - **柔性数组**：在分配结构体内存时，一次性分配整个结构体和柔性数组所需的内存。
>    - **指针**：需要单独为指针成员动态分配内存。
> 2. **成员访问**：
>    - **柔性数组**：成员是数组，直接访问即可。
>    - **指针**：指针指向动态分配的内存，需要通过指针进行间接访问。
> 3. **内存管理**：
>    - **柔性数组**：通常在分配结构体时一次性分配所有内存，且不易变更大小。
>    - **指针**：可以指向任何内存位置，灵活性更高，但需要单独管理内存分配和释放。
> 4. **内存布局**：
>    - **柔性数组**：内存布局固定，结构体和数组连续存储。
>    - **指针**：指针成员和实际数据的存储位置可以不连续。



## 5、下列程序的功能是将 s 中的字符串按长度由小到大排列，请为横线处选择合适的程序（）

```c
#include <stdio.h>
#include <string.h>
 
void f(char *p[], int n) {
    char *t;
    int i, j;
    for (i = 0; i < n - 1; i++)
        for (j = i + 1; j < n; j++)
            if (strlen(*(p + i)) > strlen(*(p + j))) {
                t = *(p + i);
                *(p + i) = *(p + j);
                *(p + j) = t;
            }
}
 
int main() {
    char *s[] = {"abc", "abcdef", "abbd"};
    f(s, 3);
    for (int i = 0; i < 3; i++)
        printf("%s\n", ____);
    return 0;
}
```

> A  s+i
> B  s[i]
> C  *s[i]
> D  &s[i]

> 答案：B
>
> 解析：对于s + i来说，s是一个char \*\*类型的指针,所以在他运算结束后还是char \*\*类型
>
> 对于s[i]来说，是一个指向字符的指针类型 (char*)，因此用来输出%s的结果
>
> 对于\*s[i]直接就是该字符串，
>
> &s[i]和第一个结果一致

## 6、若变量a, i已正确定义，且i已正确赋值，合法的语句是（ ）

> A a = int(i);
> B a == 1
> C ++i;
> D a = a++ = 5;

> 答案：C
>
> 解析：首先是题目，i已经正确赋值，则可以进行++操作，对于D来说，a没有正确赋值，也无法作比较，
>
> 对于答案A来说，强制类型转换是（int）i；

## 7、2022 迅雷 C++，现在有以下语句： 则执行后，变量sz的值将得到

```C
struct _THUNDER{ 
  int iVersion; 
  char cTag; 
  char cAdv; 
  int iUser; 
  char cEnd; 
  }Thunder; 
  int sz=sizeof(Thunder); 
  
```

> A 11
> B 12
> C 13
> D 16

> 答案：16 [sizeof](#sizeof)
>
> 解析： 结构体成员按照定义时的顺序依次存储在连续的内存空间，但是结构体的大小并不是简单的把所有成员大小相加，而是遵循一定的规则，需要考虑到系统在存储结构体变量时的地址对齐问题。
>
> 1、 没有成员的结构体占用的空间是多少个字节？ 答：1字节，确保每个实例都有一个唯一的地址。
>
> 2、在实际中，存储变量时地址要求对齐，编译器在编译程序时会遵循两条原则：
>
> ​       （1）结构体变量中成员的偏移量必须是成员大小的整数倍（0被认为是任何数的整数倍） 
>
> ​	   （2）结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。 

## 8、2022 腾讯 C++ 假设MyClass为一个类，则执行“MyClass a[5], *b[6]”语言会自动调用该类构造函数的次数是？

> A 2
> B 4
> C 5
> D 9

> 正确答案：C
>
> 解析：MyClass a[5]，会创建5个对象，所以会自动调用5次构造函数，但是MyClass *b[6],这不会自动调用构造函数，因为这是声明一个指向6个元素的数组的指针，指针声明的时候是不分配空间的，所以不会调用构造函数，没有指向一个有效的内存空间。

## 9、2021 海康威视 Makefile下面哪个初始化是非法的（按照顺序）

```
A int i = 1
B const int ic = i
C const int *pic = &ic
D int*const cpi = &ic
```

> 答案：D
>
> 解析：A变量i初始化正确，接着使用ic为整型常量，在运行时由i赋值，随后(const int )\* =&(const int)
>
> 但是对于D来说，(int *  const)= &(const int)因此是错误的
>
> 

## 10、2022 迅雷 C++有如下程序段：请问运行Test函数结果是：

```
  voidGetMemeory(char*p) 
  { 
  p=(char*)malloc(100); 
  ｝ 
  voidtest() 
  { 
  char *str=NULL; 
  GetMemory(str); 
  strcpy(str,”Thunder”); 
  strcat(str+2,“Downloader”); 
  printf(str); 
  }
```

> A ThunderDownloader
> B underDownloader
> C Thunderownloader
> D 程序崩溃

> 答案：D
>
> 解析：由于str一开始为Null，而在函数中申请的内存空间随着该函数运行结束，则分配的内存空间也被释放掉，因此str指针指向的还是空，所以后续进行strcpy操作会报错。





# 5/20号

## 1、2022 迅雷 C++ 下列for循环的循环体执行次数为

```
for(int i=10, j=1; i=j=0; i++, j--)
```

> A 0
>
> B 1
>
> C 无限
>
> D 其他选项都不对

>  答案: A
>
> 解析：对于i=j=0;这个表达式最后返回的结果是0，根据 C 语言的运算符优先级和结合性，表达式 `i = j = 0` 会从右向左进行计算。 
>
> - `j = 0` 将 `j` 设置为 0，并且表达式 `j = 0` 的值也是 0。
> - `i = 0` 将 `i` 设置为 0，并且表达式 `i = 0` 的值也是 0。
> - 因此，条件部分 `i = j = 0` 的最终值是 0。 

## 2、2022 迅雷 C++ a,b均为不等于0的整形变量，以下关系式恒成立的是：

> A a\*b/a\*b==1
>
> B a/b*b/a==1
>
> C a/b*b+a%b==a
>
> D a/b*b==a

> 正确答案：C
>
> 你的答案：A   你得按着乘法规则来，把题目看完
>
> 对于C来说，除以一个一个数之后再加上对这个数的余数就是原来的值



## 3、以下属于main函数参数的是

> A argc
>
> B envp
>
> C main
>
> D argv

> main函数有三个参数，argc、argv和envp，它的标准写法如下：
> int main(int argc,char *argv[],char *envp[])
> ** int argc，存放了命令行参数的个数。
> char argv[]，是个字符串的数组，每个元素都是一个字符指针，指向一个字符串，即命令行中的每一个参数。
> char *envp[]，也是一个字符串的数组，这个数组的每一个元素是指向一个环境变量的字符指针。 



## 4、设：char w; int x; float y; double z; 则表达式: w*x+z-y 值的数据类型是（） 

```
A float
B double
C int
D char
```

> 答案：B
>
> 解析: 低级向高级转化。 若要高精度向低精度转化则需要进行强制转换（int）i



## 5、以下代码编译有错误，哪个选项能解决编译错误？ 

```
class A {
    public:
        int GetValue() const {
            vv = 1;
            return vv;
         }
    private:
        int vv;
};
```

> A 改变成员变量"vv"为"mutable int vv"
>
> B 改变成员函数"GetValue"的声明，以使其不是const的
>
> C 都不能修复编译错误
>
> D 都可以修复编译错误

> 答案： D
>
> 解析：对于这个题目考的是[常函数](#常函数)和mutable关键字，普通成员函数后面加上 const 修饰，就是常函数。 
>
> 常函数中的 this 指针是常指针，不能在常函数中对成员变量进行修改，只能读取； 如果想要在常函数中对成员变量进行修改，可以在成员变量前加上 mutable 关键字进行修饰；
> 常函数可以被普通对象或者常对象调用，但是常对象只能调用常函数，常对象只能读成员。 

## 6、求函数返回值，输入x=9999

```
int func(int x){
    int count = 0;
    while (x){
        count++;
        x = x&(x - 1);//与运算
    }
    return count;
}
```

> A 8
>
> B 9
>
> C 10
>
> D 12

> 答案：A
>
> 解析：对于 &(与运算) ^（异或运算）|（或运算）他们是如何计算的，
>
> 假设A=60， B=13,以二进制形式表示结果为：
>
> A = 0011 1100    B = 0000 1101 
>
> A&B = 0000 1100
>
> A | B = 0011 1101
>
> A ^ B = 0011 0001  
>
> - **基本性质**：相同为 0，不同为 1，与自身异或为 0，与 0 异或为自身。
>
> 对于这个题目总结规律，一个数与他的减一的数相与，则他的结果为他的二进制数的表现形式中最右侧的1变为0，对于9999的二进制为10011100001111一共八个1，则可运算八次

## 7、函数作用：将整型数组p中n个数据增大，以下代码的实现有错误，下面哪句话的表述是正确的？ 

```
void increment_ints (int p [ ], int n)
{
  assert(p != NULL);  /* 确保p不为空指针 */
  assert(n >= 0);  /* 确保n不为负数 */
  while (n)  /* 循环n次. */
  {
    *p++;          /* 增大p*/
    p++, n--;      /* p指向下一位，n减1 */
  }
}
```

> A \*p++应该改为(\*p)++
>
> B 数组的值是一个不能改变的值，所以p不能直接被修改。应该使用一个和p相关联的指针来完成这个操作。
>
> C while循环的条件必须是一个布尔类型的表达式，表达式应该为n!=0.
>
> D p不应该定义为变长的数组，参数中不应该包含参数n。

> 答案：A
>
> 解析：首先还是优先级的问题，后缀++和--的优先级高于前缀++和--，然后高于解引用\*,所以对于第八行代码，应该是*（p++ ）, 对于B选项，来说，数组作为参数传递的时候可以使用形参名进行增加

## 8、假设在上下文和头文件正常的情况以下，下面程序的结果是什么（） 

```
char* f(char *str, char ch) {
    char *it1 = str;
    char *it2 = str;
    while (*it2 != '\0') {
        while (*it2 == ch) { it2++; }
        *it1++ = *it2++;
     }
    return str;
}
int main(int argc, char *argv[]) {
    char *a = new char[10];
    strcpy(a, "abcdcccd");
    cout << f(a, 'c');
}
```

> A abdcccd
>
> B abdd
>
> C abcc
>
> D abddcccd

> 答案：D
>
> 仔细阅读代码

## 9、若有以下说明和定义语句： 考虑内存对齐，则变量aa所占内存的字节数是（    

```
union uti {
    int n;
    double g;
    char ch[9];
} 
struct srt {
    float xy;
    union uti uv;
} aa;
```

> A 9
>
> B 8
>
> C 24
>
> D 13

> 答案：C
>
> 解析：为了确定union的大小，我们对齐的时候应该参照内部的数据类型的最大对齐字节，但是在实际计算的时候又要考虑char ch[9]，所以他的实际大小是16字节，但是对齐是八字节。
>
> 对齐和该结构体的大小是两个概念



## 5/21号

## 1、有如下程序段： 则对函数fun的调用语句正确的是 

```C
char fun(char *);
main() { char *s = "one", a[5] = {0}, (*f1)(char *) = fun, ch; }
```

> A  *f1(&a);
>
> B  f1（*s）;
>
> C  f1(&ch);
>
> D  ch = *f1(s);要改成（*f1）(s)才正确

> 答案：CD
>
> 解析：对于A来说，应该是(\*f1)(&a[0])
>
> B: f1(s)  其实也不太对，s应该是const char \*
>
> 对于函数指针来说，使用该函数指针的方法只能为p()和(*p)() 



## 2、T是一个数据类型，关于std::vector::at 和 std::vector::operator[] 描述正确的是：

> A  at总是做边界检查， operator[] 不做边界检查.
>
> B  at 不做边界检查， operator[] 做边界检查.
>
> C  at和operator[] 是一样的

> 答案：A
>
> 解析：访问vector中的数据时，使用两种方法来访问。 
>
> 1、  vector::at()    //主要推荐使用，因为at()进行了边界检查 ，如果索引越界 `std::out_of_range` 异常 
> 2、  vector::operator[]  //为了与C语言兼容 
>
> - `vector::at()`：由于包含边界检查，访问速度相对较慢。
> - `vector::operator[]`：没有边界检查，访问速度更快。
> - `vector::at()`：进行边界检查，如果索引越界会抛出 `std::out_of_range` 异常。
> - `vector::operator[]`：不进行边界检查，如果索引越界，行为未定义。

## 3、编译错误和运行时错误：

在 C++ 中，如果分母为 0，则会发生运行时错误 ,上述代码中的 `try-catch` 块并不会捕获到除以零的错误，因为这是一个未定义行为，不是 C++ 标准库抛出的异常。 

对于浮点数除以零，根据 IEEE 754 标准，结果是无穷大（`INF`）或负无穷大（`-INF`），不会抛出异常。以下是一个示例 



## 4、以下叙述中正确的是（） 

> A  结构体数组名不能作为实参传给函数
>
> B 结构体变量的地址不能作为实参传给函数
>
> C 结构体中可以含有指向本结构体的指针成员
>
> D 即使是同类型的结构体变量，也不能进行整体赋值

> 答案：C
>
> 解析：对于D来说，类型相同的结构体变量，可以进行整体赋值



## 5、32位系统下，对于下面的结构体A和B，sizeof（A），sizeof（B）的结果分别是（） 

> 主要时对于#pragma pack(``2``)代码的理解，当设置这个之后，设置结构体对齐方式为2字节
>
> 当#pragma pack()  回复默认对齐方式
>
> 答案为：8,12 

```
#include <stdio.h>
#pragma pack(2)
struct A
{
   int a;
   char b;
   short c;
};
#pragma pack()
#pragma pack(4)
struct B
{
   char b;
   int a;
   short c;
};
#pragma pack()
int main()
{
   printf(“sizeof(A)=%d,sizeof(B)=%d\n”,sizeof(A),sizeof(B));
   return 0;
}
```



## 6、下面对一维数组 a 进行正确的初始化的语句是（） 

> A  int a[10] = (0, 0, 0, 0, 0); //注:这里是小括号
>
> B  int a[10] = {};
>
> C  int a[10] = {10};
>
> D  int a[10] = {10, 0, -1};

> 答案：BCD
>
> 对于B选项，这个是正确的直接全部初始化为0

## 7、下面说法中正确的是（） 

> A  若全局变量仅在单个C 文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度
>
> B  若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度
>
> C  设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑变量生命周期问题
>
> D  静态全局变量使用过多，可那会导致动态存储区(堆栈)溢出

> 答案：A
>
> 解析：A选项：变量分为全局变量和局部变量，局部变量和形参的作用域是函数内部，全局变量的作用域是整个文件。但是可以通过一个extern的全局变量拓展全局变量的作用域，也可以通过定义一个static的全局变量限制这个拓展
>
> B:如果全局变量仅仅由单个函数访问， 不存在耦合度的问题
>
> C：动态全局变量，静态全局变量，静态局部变量的声明周期都为程序运行期间，其中进行局部变量的生存周期虽然为整个源程序，但是其作用域仍然与局部变量相同，当推出函数时，改变了还存在，但是不能使用 
>
> D: 全局变量和静态变量都是存储在静态存储区，所以在递归调用是不会压栈，也不会造成堆栈溢出。  

## 8、以下函数用法正确的个数是： 

```
void test1(){
    unsigned char array[MAX_CHAR+1],i;
    for(i = 0;i <= MAX_CHAR;i++){
        array[i] = i;
    }
}
char*test2(){
    char p[] = "hello world";
    return p;
}
char *p = test2();
void test3(){
    char str[10];
    str++;
    *str = '0';
}
```

> A 0
>
> B 1
>
> C 2
>
> D 3

> 答案：A
>
> 解析：重点不在于CHAR_MAX的取值是多少，而是在于i的取值范围是多少。 一般char的取值范围是-128到127，而u char 则是0~255，所以i的取值范围是0~255. 所以当CHAR_MAX常量大于255时，执行i++后，i不能表示256以上的数字，所以导致无限循环。 第二个问题： 重点在于函数中p的身份，他是一个指针，还是数组名； 如果是指针p，则p指向存放字符串常量的地址，返回p则是返回字符串常量地址值，调用函数结束字符串常量不会消失（是常量）。所以返回常量的地址不会出错。 如果是数组p，则函数会将字符串常量的字符逐个复制到p数组里面，返回p则是返回数组p，但是调用函数结束后p被销毁，里面的元素不存在了。 例子中p是数组名，所以会出错，p所指的地址是随机值。 若是把char p[]="hello";改成char *p="hello";就可以了。 第三个问题： 重点在于str++;这实际的语句就是str=str+1;而str是数组名，数组名是常量，所以不能给常量赋值。（可以执行str+1，但是不能str=.） 

## 9、声明一个指向含有10个元素的数组的指针，其中每个元素是一个函数指针，该函数的返回值是int，参数是int*，正确的是（ 

> A  (int *p[10])(int*)
>
> B  int [10]*p(int *)
>
> C int (*(*p)[10])(int *)
>
> D int ((int *)[10])*p
>
> E 以上选项都不正确

> 答案：C
>
> 解析：首先顶一个数组指针，int (\*ptr)[10],接着定义一个函数指针int (\*pf)(int \*),接着定义一个元素时函数指针的指针数组，即将这个(\*ptr)[10]作为一个整体代替pf,.

## 10、有如下代码: 

```
struct A1{
    virtual ~A1(){}
};
struct A2{
    virtual ~A2(){}
};
struct B1 : A1, A2{};
int main()
{
 B1 d;
 A1* pb1 = &d;
 A2* pb2 = dynamic_cast<A2*>(pb1);  //L1
 A2* pb22 = static_cast<A2*>(pb1);  //L2
 return 0;
}
```

> A  L1语句编译失败，L2语句编译通过
>
> B  L1语句编译通过，L2语句编译失败
>
> C  L1，L2都编译失败
>
> D  L1，L2都编译通过

> 正确答案：B 
>
> 解析：
>
> - C 风格的类型转换（C-style casting）：使用一对圆括号来实现类型转换，如 `(int)x`。
> - 函数风格的类型转换（Function-style casting）：使用 C++ 的类型转换函数来实现类型转换，如 `int(x)`。
> - `static_cast`：用于执行静态类型转换，具有较强的类型检查。 static_cast<目标类型>(原类型)  目标类型和源类型之间必须一个方向可以自动类型转换，否则就会出现 错误。  
> - `dynamic_cast`：用于执行动态类型转换，通常用于类的多态类型转换。dynamic_cast<目标类型>(原类型)  源类型和目标类型之间必须存在继承关系，否则会出现错误。  
> - `const_cast`：用于移除变量的 `const` 属性或添加 `const` 属性。const_cast<目标类型>(原类型)  源类型和目标类型必须是指针或引用，且间除了const属性外，其它都相同，否则就会出现错误。   
> - <a name="reinterpret_cast">reinterpret_cast</a>：用于执行底层的指针类型之间的转换，通常用于需要对底层数据进行原始操作时。 reinterpret_cast<目标类型>(原类型)  只能把整数转换成指针或把指针转换成整数，否则就会出现错误。 `reinterpret_cast` 并不仅仅限制于整数和指针之间的转换，它可以执行任意类型之间的转换，但是其使用具有风险，可能导致未定义的行为。 应尽量避免使用。



# 5/22号

## 1、有以下语句定义 ，有语法错误的是（）

```C
int x =5;
const int * const p = &x;
const int &q=x; 
int const *next=&x;
const int *j=&x;
```

> A  * p =1;
>
> B  q++;
>
> C  next++;
>
> D  (*j)++;

> 正确答案：ABD
>
> 你的答案：AD
>
> 解析：A ：`p` 是一个指向 `const int` 的 `const` 指针。即 `p` 指向一个常量整数，且 `p` 本身也是常量，不能修改。尝试通过 `*p` 修改其指向的值是非法的，因为 `*p` 是 `const`。
>
> B： `q` 是对 `x` 的 `const int` 引用。因为 `q` 是常量引用，不能通过 `q` 修改 `x` 的值。尝试递增 `q` 会导致错误。
>
> D: `j` 是一个指向 `const int` 的指针。`*j` 解引用指针 `j` 得到的是一个 `const int`，不能修改其值。因此，尝试递增 `*j` 会导致错误。



## 2、使用printf函数打印一个double类型的数据，要求：输出为10进制，输出左对齐30个字符，4位精度。以下哪个选项是正确的？

> A  %-30.4e
>
> B %4.30e
>
> C %-30.4f
>
> D %-4.30f

> 正确答案：C
>
> 你的答案：D
>
> 解析： -： 左对齐 
>
>   30： 最小字段宽度 
>
>   .4： 精确度保留小数4位 
>
>   f： double精度浮点数 
>
>   e： 科学计数法
>
> printf中的格式输出修饰符：m.n
>
> m表示输出域宽，若m为负整数，则输出数据在域内左对齐
>
> n表示显示精度，对于浮点数，用于指定输出的浮点数的小数位，对于字符串，用于指定从字符串左侧开始截取子串字符个数

## 3、以下叙述中正确的是（） 

> A 在算法设计时，可以把复杂任务分解成一些简单的子任务
>
> B 在C语言程序设计中，所有函数必须保存在一个源文件中
>
> C 只要包含了三种基本结构的算法就是结构化程序
>
> D 结构化程序必须包含所有的三种基本结构，缺一不可

> 正确答案：A
>
> 解析以下三种基本结构和结构化程序：结构化程序可以包含三种基本结构中的一种或几种
>
> 1)顺序结构：顺序结构是一种线性、有序的结构,它依次执行各语句模块. 
>  2)循环结构：循环结构是重复执行一个或几个模块,直到满足某一条件为止. 
>  3)选择结构：选择结构是根据条件成立与否选择程序执行的通路.



## 4、下列代码输出是（） 

```
char *a[] = {"BEIJING", "SHENZHEN", "SHANGHAI", "GUANGZHOU"};
char **pa[] = {a+3, a+2, a+1, a};
char ***ppa = pa;
int main(void) {
    printf("%s, ", **++ppa);
    printf("%s, ", *--*++ppa+3);
    printf("%s, ", *ppa[-2]+3);
    printf("%s", ppa[-1][-1]+1);
}
```

> A  BEIJING, SHENZHEN, SHANGHAI,GUANGZHOU
>
> B SHANGHAI, JING, NGZHOU, HENZHEN
>
> C SHANGHAI,BEIJING, GUANGZHOU, SHENZHEN
>
> D SHANGHAI,EIJING,ZHOU,ZHEN

> 答案：B
>
> ![图片说明](https://uploadfiles.nowcoder.com/images/20200105/831729261_1578207736656_13CA8422D2DE4A56BC0A6648BC5B674F) 

```
/*
  对于指针ppa
        指针类型：char ***
        指针指向：pa[0]
        指针指向类型：char **
  //指针的指向决定其偏移起始位置，指针指向的类型决定其每次移动偏移量大小 
*/
printf("%s, ", **++ppa);
/*
    运算符优先级：++ 与 * 运算符同优先级，结合性都是自右向左
    ++ppa
        ppa自增，指向改变，向后移动一位,偏移量为char **,指向pa[1]
    *++ppa
        取出内容,pa[1],pa[1]又指向a[2]
    **++ppa
        取出内容,a[2],a[2]又指向字符串"SHANGHAI",printf输出 SHANGHAI
*/
printf("%s, ", *--*++ppa+3);
/*
    运算符优先级：++/-- 优先级大于 + ,且 + 的结合性是从左往右
    ++ppa
        上一次操作已改变ppa的指向为pa[1],再次移动，指向pa[2]
    *++ppa
        取出内容,pa[2],pa[2]又指向a[1]
    --*++ppa
        //此时，【*++ppa】是一个char **指针，指向a[1],
//则其偏移的起始位置为a[1],偏移量为char *
        --使其自减，指针向前移动，从a[1]向前移动一个char*的大小，指向a[0]
    *--*++ppa
        取出内容，a[0]，a[0]又指向字符串"BEIJING"
    *--*++ppa+3
        //此时【*--*++ppa】是一个char *指针，指向一个字符串，则其偏移的起始位置
//为字符串的首字符，偏移量为char
        +3使指针向后移动3次，每次移动一个char，移动完成后指向字符'J' ,printf
输出，从字符'J'的位置往后输出打印到STDOUT,输出 JING
*/
 printf("%s, ", *ppa[-2]+3);
/*
    []作用符：【例子】
    int arr[]{ 0,1,2,3 };
    int *p=arr;
    ++p;
    cout << p[1] << " " << *(p + 1) << endl;
    cout << p[-1] << " " << *(p - 1) << endl;
    //p[1]等价于*(p + 1)   p[-1]等价于*(p - 1)
    ppa[-2]
        等价于*(ppa-2)
            ppa-2
                //经过前两次操作，ppa指向pa[2],移动后指向pa[0],【但ppa
//本身的指向并没有改变，还是指向pa[2]】
            *(ppa-2)
                取出内容，pa[0],pa[0]又指向a[3]
    *ppa[-2]
        取出内容，a[3]，a[3]又指向字符串"GUANGZHOU"
    *ppa[-2]+3
        +3使指针移动到字符'N',printf输出 NGZHOU 
*/
printf("%s", ppa[-1][-1]+1);
/*
    //类似与ppa[-2]等价于*(ppa-2),ppa[-1][-1]等价于*(*(ppa-1)-1)
    ppa[-1]
        等价于*(ppa-1)
            //经过前三步操作，ppa指向pa[2]，移动后，指向pa[1],
//取出内容pa[1],pa[1]又指向a[2]
    ppa[-1][-1]
        等价于*(*(ppa-1)-1)
            *(ppa-1)-1
                将上一步操作中的*(ppa-1)看做一个整体，是一个char **指针，
指向类型为char * 的a[2]
                则指针 *(ppa-1) 偏移的起始位置为a[2]，向前移动一次，
偏移量为char *,移动后指向a[1]
            *(*(ppa-1)-1)
                取出内容，a[1]，a[1]又指向字符串"SHENZHEN"
    ppa[-1][-1]+1
        +1指针其移动到字符'H',printf输出 HENZHEN
*/
```



## 5、在上下文及头文件均正常的情况下，设：有以下代码，,执行 printf("%d", r) ;后的输出结果是 

```
enum color { red, yellow = 2, blue, white, black }  //0 2 3 4 5，如果red和yellow中有一个puprle，则该值为1
r = white;
```

> A  0
>
> B  1
>
> C  3
>
> D  4

> 正确答案：D
>
> 你的答案：A
>
> 解析： enum是枚举类型，枚举类型在使用中有以下规定： 1、 **枚举值是常量，不是变量。不能在程序中用赋值语句再对它赋值。** 对枚举  weekday  的元素再作以下赋值： sun=5;  mon=2;  sun=mon;   都是错误的。 **2、枚举元素本身由系统定义了一个表示序号的数值**，从0开始
> **3、只能把枚举值赋予枚举变量，不能把元素的数值直接赋予枚举变量** 
> **4**、**枚举中若某一元素被赋值，则其后的元素值依次在原值上递加1** 
> 如果yellow不赋值为2，则red应为0，后面的元素值依次递加，依次为 0 1 2 3 4，但是现在yellow=2，故red=0,yellow后元素依次在2的基础上递加，结果为 0 2 3 4 5 
## 6、参加位运算的数据可以是任何类型的数据。请问这句话的说法是正确的吗？ 

> A  正确
>
> B  错误

> 答案：十进制浮点数无法转化为精确的二进制浮点数 ，所以不正确



## 7、以下叙述中正确的是（） 

> A  预处理命令行必须位于源文件的开头
>
> B  在源文件的一行上可以有多条预处理命令
>
> C  宏名必须用大写字母表示
>
> D  宏替换不占用程序的运行时间

> 正确答案：D 
> 预处理命令行可以出现在源程序的任何位置上，因此选项A的说法是错误的。源程序的一行上只能出现一条预处理命令，因此选项B的说法也是错误的。宏名只要是符合要求的标识符都可以，没有规定一定要大写，因此选项C的说法也是错误的。宏替换在程序编译时，就由编译程序对出现的宏名进行了相应的宏替换，因此宏替
> 换不占用程序的运行时间。选项D的说法是正确的。



## 8、函数的形式参数隐含的存储类型说明是（） 

> 函数的隐含储存类型是extern,函数的形参或变量的储存类型为auto    

## 9、以下叙述正确的是（）

> A  在一个程序中，允许使用任意数量的#include命令行
>
> B  在包含文件中，不得再包含其他文件
>
> C  #include命令行不能出现在程序文件的中间
>
> D  虽然包含文件被修改了，包含该文件的源程序也可以不重新进行编译和连接

> 正确答案：A
>
> 你的答案：C
> 首先包含文件可以包含其他文件，其次#include可以出现在程序文件的中间，最后包含文件被修改，包含该文件的源程序必须进行重新编译和链接



## 10、一个双目运算符作为类的成员函数重载时，重载函数的参数表中有()个参数。

> A  1
>
> B  2
>
> C 3
>
> D  0

> 正确答案：A
>
> 你的答案：B
> A 重载为类成员函数时，类本身是该双目运算符的一个参数，所以还需要一个参数 如果重载为友元函数则需要两个参数 



# 5/23号

## 1、有以下程序 程序运行后的输出结果是() 

```
#include<iostream>
#include<cstdio>
using namespace std;
int main(){
  int m=0123, n = 123;
  printf("%o %o\n", m, n);
  return 0;
}
```

> A  0123 0173
>
> B 0123 173
>
> C  123 173
>
> D 173 173

> 正确答案：C
>
> 你的答案：A
> 对于输出八进制和十六进制，不会再前面输出0和0x
>
> 再o和x前面加上#会输出0和0x



## 2有以下程序 程序运行后的输出结果是（） 

```
#include <stdio.h>
main() {
    int a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p = a + 5, *q = NULL;
    *q = *(p+5);
    printf("%d %d\n", *p, *q);
}
```

> A 运行后报错
>
> B  6 6
>
> C 6 11
>
> D 5 10

> 正确答案：A
>
> 你的答案：C
> 解析：为什么会报错，首先就是说\*q = NULL, 后边直接将*q  = 数值，肯定是错误的，应为一开始的指针瞎指的，所以不应该这样赋值，而是直接让q = p + 5,即修改q指针指向的地址即可



## 3、关于操作系统heap与stack说法中，正确的是（）。 

>  A stack由编译器自动分配和释放,存放函数的参数值，局部变量，全局变量的值 
>
> B heap一般由程序员分配和释放，若程序员不释放，可能会造成操作系统的内存泄露 
>
> C stack由系统自动分配，无需程序员干涉，heap需要手动申请 
>
> D heap与stack都会在初始大小空间用满时，系统自动增加其大小 

> 答案：BC
>
> 解析：

- **选项 A**：错误。
  - 栈（stack）由编译器自动分配和释放，存放函数的参数值和局部变量，但不存放全局变量的值。全局变量存储在全局数据区（静态区），不是在栈中。
- **选项 B**：正确。
  - 堆（heap）通常由程序员通过动态内存分配函数（如 `malloc`、`calloc`、`realloc`、`new` 等）进行分配，并通过 `free` 或 `delete` 来释放。如果程序员不释放内存，就会造成内存泄漏（memory leak），因为操作系统不会自动回收这些内存。
- **选项 C**：部分正确。
  - 栈（stack）由系统自动分配和释放，无需程序员干涉。
  - 堆（heap）需要程序员手动申请和释放。
  - 但是，这个选项并不全面地说明栈的自动释放和堆的手动管理，只是部分正确。
- **选项 D**：错误。
  - 栈的大小通常在程序启动时确定，并且系统不会自动增加栈的大小，如果栈空间不够会导致栈溢出（stack overflow）。
  - 堆的大小可以在程序运行时动态调整，但需要程序员手动管理，不是系统自动增加。



## 4、C语言中的一个变量可以被定义为两个或多个不同的类型。请问这句话的说法是正确的吗？ 

> A  正确
>
> B  错误
>
> 正确答案：A
>
> 你的答案：B

> 解析：全局变量和局部变量之分



## 5、(c语言)在二维数组int a\[2]\[4]=\{\{2,4,5,7\},\{3,6,1,8\}\}中，*(&a\[0]\[0]+4)的值是（ ）

> A &a\[0]\[4]
>
> B 6
>
> C 3
>
> D a\[0]\[4]

> 答案：C
>
> 解析：首先a\[0]\[0]其实已经是一个数，第一行第一个数值，对他进行取地址则&a\[0][0] 的类型是int \*
>
> 对于int \*进行偏移，则每次移动一个int，因此相当于a\[1][0] 



## 6、下面程序运行后的结果为： 

```
char str[] = "glad to test something";
char *p = str;
p++;
int *p1 = reinterpret_cast<int *>(p);
p1++;
p = reinterpret_cast<char *>(p1); 
printf("result is %s\n", p);
```

> A  result is glad to test something
>
> B result is ad to test something
>
> C result is test something
>
> D result is to test something

> 正确答案：D   你的答案：B
>
> 解析：首先是对于[reinterpret_cast](#reinterpret_cast), 然后分析，p ++ 此时p指向l，然后将类型转换p1为int \*，接下来p1++，相当于移动了一个int 四字节，此时指向t，然后将指针转换成char \*进行输出，则此时也还是指向t



## 7、为了提高程序的运行速度，在函数中对于整型或指针可以使用（）型的变量。 

> A  auto
>
> B  register
>
> C  static
>
> D extern

> 答案: B
>
> 解析：  auto 变量类型推演，
>
>    register 建议编译器将该变量放入cpu，
>    static 静态变量，
>    extern 声明变量，常用于多文件需要使用同一变量时

## 8、下面程序段执行后的输出结果是（）（□表示一个空格） 

```
int a=3366;
printf("│%-08d│",a);
```

> A  │-0003366│
>
> B  │00003366│
>
> C  │3366□□□□│
>
> D  输出格式非法

> 正确答案：C
>
> 你的答案：B
>
> 左对齐的话使用0填充无意义，会被忽略掉
>
> 默认是右对齐

```
       123|
     hello|  //右对齐
```

```
123       |
hello     |  //左对齐
```

# 5/24号

## 1、下面哪种C/C++ 分配内存的方法会将分配的空间初始化为0 

> A malloc()
>
> B  calloc()
>
> C  realloc()
>
> D  new[ ]

> 答案：B
>
> 1) malloc 函数： void *malloc(unsigned int size)
>
> ​     在内存的动态分配区域中分配一个长度为size的连续空间，如果分配成功，则返回所分配内存空间的首地址，否则返回NULL，申请的内存不会进行初始化。 
>
>  2）calloc 函数： void *calloc(unsigned int num, unsigned int size)
>
> ​     按照所给的数据个数和数据类型所占字节数，分配一个 num * size 连续的空间。 
>
> ​    calloc申请内存空间后，会自动初始化内存空间为 0，但是malloc不会进行初始化，其内存空间存储的是一些随机数据。      
>  3）realloc 函数： void *realloc(void *ptr, unsigned int size) 
>
> ​    动态分配一个长度为size的内存空间，并把内存空间的首地址赋值给ptr，把ptr内存空间调整为size。 
>
> ​    申请的内存空间不会进行初始化。
> ​    4）new是动态分配内存的运算符，自动计算需要分配的空间，在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。动态分配内置类型是否自动初始化取决于变量定义的位置，在函数体外定义的变量都初始化为0，在函数体内定义的内置类型变量都不进行初始化。

1. **`malloc` 函数**:
   ```c
   void *malloc(size_t size);
   ```
   在动态内存分配区域中分配一个长度为 `size` 字节的连续空间。如果分配成功，则返回所分配内存空间的首地址，否则返回 `NULL`。申请的内存不会进行初始化。

2. **`calloc` 函数**:
   ```c
   void *calloc(size_t num, size_t size);
   ```
   按照所给的数据个数和每个数据类型所占字节数，分配一个 `num * size` 字节的连续空间。`calloc` 申请内存空间后，会自动初始化内存空间为 0。

3. **`realloc` 函数**:
   ```c
   void *realloc(void *ptr, size_t size);
   ```
   调整之前分配的内存块的大小为 `size` 字节。它可能会移动内存块到一个新的位置，并复制旧内存块的数据到新位置。如果 `ptr` 是 `NULL`，则 `realloc` 的行为类似于 `malloc`。新分配的内存部分不会进行初始化。

4. **`new` 运算符**:
   `new` 是动态分配内存的运算符，自动计算需要分配的空间。在分配类类型的内存空间时，同时调用类的构造函数，对内存空间进行初始化，即完成类的初始化工作。对于内置类型，使用 `new` 动态分配的内存不会自动初始化，除非显式提供初始值。

## 2、字符串只能存放在字符型数组中。请问这句话的说法是正确的吗？ 

> A  正确
>
> B 错误

> 正确答案：B
>
> 你的答案：A
>
> 解析：还能放在常量区，然后使用指针指向它

```C
char str[] = "Hello, world!";  //存储在数组
char *str = "Hello, world!";   //存储在常量区
```





## 3、turbo c环境下，下面程序运行的结果是()

```
#include <stdio.h>
int main() {
    printf("\n");
    int a[5] = {1, 2, 3, 4, 5};
    int *p, **k;
    p = a;
    k = &p;
    printf("%d", *(p++));
    printf("%d", **k);
    return (0);
}
```

> A  11
>
> B  21
>
> C  22
>
> D  12

> 答案：
> 解析：首先是\*p 指向数组的起始地址，他的偏移量是int，但是在p++之后，由于k是指向p的地址，k->p->2。所以对于第九行输出的是2

## 4、阅读以下程序，当输入数据的形式为25,13,10↙，正确的输出结果为（） 

> A  x+y+z=48
>
> B  x+y+z=38
>
> C  x+y+z=35
>
> D  无法确定

正确答案：D

你的答案：A

官方解析：【解释】当一次scanf调用需要输入多个数据项时，如果前面数据的输入遇到非法字符，并且输入的非法字符不是格式控制字符串中的常规字符，那么，这种非法输入将影响后面数据的输入，导致数据输入失败。当输入为25,13,10时，a的值是25，y和z的值将无法预测，所以x+y+z的值是无法确定的。故正确答案是D。

## 5、下面可以检测运算过程中出现整型溢出的办法有（） 

> A  将运算结果和可以表示的最大整数进行比较
>
> B  检测符号位的变化
>
> C  将计算结果减去加数看是否与另一加数相等
>
> D  比较参数的长度

> 正确答案：BC  你的答案：ABC
>
> 解析：对于A 来说运算结果进行比较的话，已经溢出导致结果变化，去比较也为时已晚。 所以不正确  

## 6、C语言中，在头文件正常引用的情况下，执行 后，输出结果为

```C
printf("%5s", "abcdefg");
```

> A  abcde
>
> B  abcdefg
>
> C  cdefg
>
> D  输出错误信息

> 答案：B
>
>  "%5s",表示输出至少5个字符，不够的话，左侧用空格补。 多的话全部输出
>
>   %.5s，最多输出5个字符

# 5/25号

## 1、C语言中允许函数值类型缺省定义，此时该函数值隐含的类型是int。 

> A 正确
>
> B 错误
>
> 正确答案：A
>
> 你的答案：B

>一、返回值 
>
> C中：如果函数未指定返回值类型，则默认为int 
>
>c++中：如果一个函数没有返回值，返回值类型必须指定为void 
>二、参数列表 
>
>C中：如果函数没有指定参数列表，则默认可以接受任意多个参数 
>
>C++中：有严格的类型检测，没有参数列表的函数默认为void，不接受任意参数 
>
>三、缺省参数（即给参数一个默认值） 
>C:不支持
>C++:支持（如果没有指定实参则使用缺省值，有则使用指定实参） 
>1.默认实参必须在参数列表的结尾
>2.默认参数只能出现在函数声明或者定义二选一中
>3.缺省值必须是常量或全局变量
>4.缺省参数必须是值传递或者常参传递 
>四、函数重载
> C:不支持
> C++:支持在同一作用域中存在几个功能类似的同名函数，但参数列表（参数个数、类型、顺序）不同

## 2、在32位机器上用gcc编译以上代码，求sizeof(A)，sizeof(B)分别是（） 

```C
class A {
    int a;
    short b;
    int c;
    char d;
};
class B {
    double a;
    short b;
    int c;
    char d;
};
```

> A  12 16
>
> B  12 12
>
> C  16 24
>
> D  16 20

> 答案：C
>
> 解析：在进行分析的时候  A中最大的是int的四字节，对于字节对齐来说，不单单要字节数是该类型的倍数
>
> int 4 short 2(他从四字节位置开始，是2的倍数) 对于下一个int 4(此时字节数为6，不是4的倍数，因此应该从8字节处计算，所以此时是12字节) 对于char来说，都是1字节，但是13不是4的倍数，整体应该是4的倍数，因此应该是16字节

## 3、下列关于类中的静态成员的说法错误的是（） 

> A  虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员
>
> B  成员函数不用通过作用域运算符就能直接使用静态成员
>
> C  静态数据成员不是由类的构造函数初始化的
>
> D  静态成员不可以作为默认实参

> 答案：D
>
> ```C
> class MyClass {
> public:
>     static int staticMember;  //静态成员是可以作为默认参数的
>     void myFunction(int param = staticMember) {
>         // Function implementation
>     }
> };
> 
> int MyClass::staticMember = 10;
> 
> ```



## 4、以下程序运行时输入：123456789↙则程序运行结果是（ ）

```C
#include <stdio.h>
int main()
{
    int x, y;
    scanf("%2d%*4s%2d", &x, &y);
    printf("%d", y - x);
    return 0;
}
```

> - `%2d`：读取最多两位数字并存储到变量 `x` 中。
> - `%*4s`：读取最多四个字符的字符串，但不保存它们（因为有 `*`，表示跳过这些字符）。
> - `%2d`：读取最多两位数字并存储到变量 `y` 中。



## 5、内联函数在编译时是否做参数类型检查? 

> A  不做检查，和宏一样
>
> B  做类型检查
>
> C  和编译器相关

>正确答案：B
>
>参考答案：做类型检查，因为内联函数就是在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来代替。[内联函数](#内联函数)

## 6、引用标准库时，下面的说法正确的是（） 

> A   语句#include “stdlib.h”是正确的，而且程序编译速度比#include< stdlib.h >要快
>
> B   语句#include< stdlib.h >是正确的，而且程序编译速度比#include “stdlib.h”要快
>
> C   语句#include< stdlib.h >和#include “stdlib.h”都是正确的，程序编译速度没有区别
>
> D   语句#include “stdlib.h”是错误的

> 正确答案：B
>
> 你的答案：D
>
> 这是因为使用尖括号 `<>` 来引用标准库头文件，比如 `#include `，告诉编译器在标准系统目录中查找头文件。通常情况下，编译器对标准系统目录的搜索进行了优化，因此速度会比使用双引号 `""` 的本地目录搜索更快。 

## 7、sizeof(s) 

```C
struct s
{
    int x: 3;
    int y: 4;
    int z: 5;
    double a;
}
```

> A  16
>
> B  32
>
> C  20
>
> D  24

>  需要看清楚该结构体中是位操作，三个变量共占用一个int类型的大小，int类型占用4个字节，double占用8个字节。为了实现内存对其，int类型需要填充4个字节的长度。 选A 
>
>    有些信息在存储时，并不需要占用一个完整的字节，而只需占用几个或一个二进制位。例如在存放一个开关量时，只有0和1两种状态，用一位二进制即可。为了节省存储空间，并使处理简单，C语言提供了一种数据结构，称为“位域”或“位段”。所谓“位域”是把一个字节中的二进制位划分为几个不同的区域，并说明每个区域的位数。每个域有一个域名，允许在程序中按域名进行操作。这样就可以把几个不同的对象用一个字节的二进制位域来表示.

## 8、使用操作符setw() 对数据进行格式输出时，应包含（ ）文件。

> A  fstream.h
>
> B  stdlib.h
>
> C  iostream.h
>
> D  iomanip.h

> D
>
> `<iomanip>` 头文件中包含了许多用于格式化输入和输出的操作符和函数，这些工具可以帮助我们更好地控制数据的显示方式。以下是一些常用的函数和操作符：
>
> ### 常用操作符
>
> 1. **`std::setw(int width)`**
>    - 设置输出字段的宽度。仅对下一次的输出操作有效。
>    - 例如：`std::cout << std::setw(10) << num;`
>
> 2. **`std::setfill(char fillChar)`**
>    - 设置填充字符。默认情况下，填充字符是空格。
>    - 例如：`std::cout << std::setfill('*') << std::setw(10) << num;`
>
> 3. **`std::setprecision(int n)`**
>    - 设置浮点数的精度（即小数点后的位数）。
>    - 例如：`std::cout << std::setprecision(3) << pi;`
>
> 4. **`std::fixed`**
>    - 将浮点数设置为定点格式。
>    - 例如：`std::cout << std::fixed << pi;`
>
> 5. **`std::scientific`**
>    - 将浮点数设置为科学计数法格式。
>    - 例如：`std::cout << std::scientific << pi;`
>
> 6. **`std::left`**
>    - 左对齐输出。
>    - 例如：`std::cout << std::left << std::setw(10) << num;`
>
> 7. **`std::right`**
>    - 右对齐输出（这是默认对齐方式）。
>    - 例如：`std::cout << std::right << std::setw(10) << num;`
>
> 8. **`std::boolalpha` 和 `std::noboolalpha`**
>    - `std::boolalpha` 使布尔值以 `true` 和 `false` 的形式输出。
>    - `std::noboolalpha` 使布尔值以 `1` 和 `0` 的形式输出（默认行为）。
>    - 例如：`std::cout << std::boolalpha << true;`
>
> ### 常用函数
>
> 除了上面的操作符，`<iomanip>` 头文件还包含一些用于格式化输入的函数：
>
> 1. **`std::get_money` 和 `std::put_money`**
>    - 用于货币格式的输入和输出。
>    - 例如：`std::cout << std::put_money(1234.56);`
>
> 2. **`std::get_time` 和 `std::put_time`**
>    - 用于时间格式的输入和输出。
>    - 例如：`std::cout << std::put_time(std::localtime(&t), "%Y-%m-%d %H:%M:%S");`
>
> ### 示例代码
>
> 以下是一个示例，展示了如何使用这些操作符和函数：
>
> ```cpp
> #include <iostream>
> #include <iomanip>
> #include <ctime>
> 
> int main() {
>     int num = 42;
>     double pi = 3.14159;
>     bool flag = true;
>     time_t t = time(nullptr);
> 
>     // 使用 setw 和 setfill
>     std::cout << "Number: " << std::setfill('*') << std::setw(10) << num << std::endl;
> 
>     // 使用 setprecision 和 fixed
>     std::cout << "Pi: " << std::fixed << std::setprecision(3) << pi << std::endl;
> 
>     // 使用 boolalpha
>     std::cout << "Flag: " << std::boolalpha << flag << std::endl;
> 
>     // 使用 put_time
>     std::cout << "Current time: " << std::put_time(std::localtime(&t), "%Y-%m-%d %H:%M:%S") << std::endl;
> 
>     return 0;
> }
> ```
>
> 这个示例演示了如何使用 `<iomanip>` 中的一些常用操作符和函数来格式化输出。



## 9、下面函数的输出结果是（） 

```C
void func() {
    int k = 1 ^ (1 << 31 >> 31);
    printf("%d\n", k);
}
```

> A  0
>
> B  -1
>
> C  -2
>
> D  1

> 答案：C   符号位：0代表正数，1代表负数。 计算机中加减运算均使用补码。
>
> 1的原码是 0000 0000 0000 0000 0000 0000 0000 0001
>
> 1 的补码 同上
>
> 1  << 31 得到 1000  0000 0000 0000 0000 0000 0000 0000  (符号位为1，)
>
> 将（1 << 31)  >> 31得到 1111 1111 1111 1111 1111 1111 1111 1111
>
> 与1进行异或运算 得到  11111111 11111111 11111111 11111110
>
> 补码，因此要再变成原码进行输出：减去1再取反，1111 1111 1111 1111 1111 1111 1111 1101
>
> 取反  1000 0000 0000 0000 0000 0000 0000 0010   = -2



| 表示方法 | 特点                                                    | 正数表示                | 负数表示                        | 示例（+3）        | 示例（-3）        |
| -------- | ------------------------------------------------------- | ----------------------- | ------------------------------- | ----------------- | ----------------- |
| 原码     | 最高位为符号位，存在两个零（+0 和 -0），负数运算复杂    | 符号位为0，其他位为数值 | 符号位为1，其他位为数值的绝对值 | `0011`            | `1011`            |
| 反码     | 最高位为符号位，负数为正数取反，存在两个零（+0 和 -0）  | 与原码相同              | 将正数所有位取反                | `0011`            | `1100`            |
| 补码     | 最高位为符号位，负数为正数取反加1，没有两个零，运算简便 | 与原码相同              | 将正数取反加1                   | `0011`            | `1101`            |
| 移码     | 常用于浮点数表示，数值加上偏移量，避免使用符号位        | 数值加偏移量            | 数值加偏移量                    | 偏移量为7: `1010` | 偏移量为7: `0100` |

* 右移运算将二进制数的所有位向右移动指定的位数，左边空出的位的填充方式取决于数值的类型和具体实现。对于无符号数，左边空出的位用0填充；对于有符号数，通常使用符号位填充（算术右移）或用0填充（逻辑右移）。 
* 左移运算将二进制数的所有位向左移动指定的位数，右边空出的位用0填充。左移n位相当于将数值乘以2的n次方（对于无符号数） 



# 5/26号

## 1、以下对结构体类型变量的定义中，不正确的是（） 

> A  typedef struct aa { int n; float m; } AA; AA td1;
>
> B  #define AA struct aa  \n AA { int n; float m; } td1;
>
> C  struct { int n; float m; } aa; stuct aa td1;
>
> D  struct { int n; float m; } td1;

> 正确答案：C  你的答案：B
>
> 第一种是最基本的结构体定义，其定义了一个结构体A。 
>
> ```C
> struct A 
> { 
> 	int a;
> };
> ```
>
>   第二种则是在定义了一个结构体B的同时定义了一个结构体B的变量m。 
>
> ```C
> struct B 
> {
>     int b;
> }m;
> ```
>
>   第三种结构体定义没有给出该结构体的名称，但是定义了一个该结构体的变量n，也就是说，若是想要在别处定义该结构体的变量是不行的，只有变量n这种在定义结构体的同时定义变量才行。 
>
> ```C
> struct{
> 	int c;
> }n;
> ```
>
>   第四种结构体定义在第一种结构定义的基础上加了关键字typedef，此时我们将struct D{int d}看成是一个数据类型，但是因为并没有给出别名，直接用D定义变量是不行的。如D test；，不能直接这样定义变量test。但struct D test；可行。 
>
> ```C
> typedef struct D //第四种 
> { 
>     int d;
> };
> struct D dd;
> ```
>
>   第五种结构体定义在第四种结构体定义的基础上加上了别名x，此时像在第四种结构体定义中说得那样，此时的结构体E有别名x，故可以用x定义E的结构体变量。用E不能直接定义，需要在前面加struct，如struct E test；。 
>
> ```C
> typedef struct E //第五种 
> {
>     int e;
> }x;
> ```
>
> ##   第六种结构体定义在第五种的基础上减去了结构体名，但是若是直接使用y来定义该结构体类型的变量也是可以的。如y test；
>
> ```C
> typedef struct {
> 	int num;
> }area;
> area a;
> ```
>
> 



## 2、sizeof( double ) 是（） 

> A  一个整型表达式
>
> B  一个双精度型表达式
>
> C  一个不合法的表达式
>
> D  一种函数调用

> 正确答案：A
>
> 你的答案：B
>
> 官方解析：【解析】 sizeof 是 C 语言中的一个操作符 (operator), 不是函数调用 , 简单的说其作用就是返回一个对象或者类型所占的内存字节数。所以选择 A 。



## 3、多态类中的虚函数表建立在（） 

> A  编译阶段
>
> B  运行阶段
>
> C  构造函数被调用时进行初始化的
>
> D  类声明时

> 答案：A
>
> 是在编译时创建的的虚函数表，编译器对每个包含虚函数的类创建一个虚函数表(vtable)，在vtable中，放置这个类的虚函数地址。编译器另外还为每个特定类的对象提供了一个虚表指针（即vptr），这个指针指向了对象所属类的虚表。 
>
>   在程序运行时，根据对象的类型去初始化vptr，从而让vptr正确的指向所属类的虚表，从而在调用虚函数时，就能够找到正确的函数。



## 4、以下程序的输出的结果是（） 

```C
int a=3;
int main ()
{
    int s=0;
    {
        int a = 5;
        s += a++;
    }
    s += a++;
    printf ("%d\n", s);
}
```

> A  8
>
> B  10
>
> C  7
>
> D  11

> 答案：8 
> 不要忘记再第一行有一个3，当再{}重新定义了一个a之后，会当作一个函数内的局部变量
>
> 因此 s += 0 + 5 = 5;  当跳出大括号之后，s  +=  3 = 8；



## 5、下列关于const关键字的说法错误的是： 

> A   用const常量代替宏定义可以让编译器进行安全性检查
>
> B  类的const成员函数不能修改类的成员变量，而且一个const类对象只能调用其const成员函数，不能调用非const成员函数
>
> C  const成员函数与同名、同返回值、同参数列表的非const成员函数属于重载现象
>
> D  推荐使用以下方面定义类成员数组： class A{ … const size_t SIZE=100; int _array[SIZE]; };

> 答案：D
>
> const成员只能在构造函数的初始化列表中初始化  ，  如果非要在类中声明处初始化，就要加上static才行，而且初始化的对象必须是整型 



## 6、对以下数据结构中data的处理方式描述正确的是() 

```C
struct Node
{
   int size;
   char data[0];
};
```

> A  data将会被编译成一个char *类型指针
>
> B  全部描述都不正确
>
> C  编译器会认为这就是一个长度为0的数组,而且会支持对于数组data的越界访问
>
> D  编译器会默认将数组data的长度设置为1

> 答案：C   [柔性数组](#柔性数组)

## 7、<a name='文件操作'>文件操作</a>

> r 可读权限 文件必须存在 若不存在打开失败报错 
>
>   r+ 可读可写权限 文件必须存在 若文件不存在打开失败报错 
>
>   w 可写权限 不允许文件读出 若文件不存在 创建文件 
>
>   w+ 可读可写文件 若文件不存在 创建文件 
>
>   a 以附加方式打开可写的文件 若文件存在 则会在文件末尾进行数据写入 若文件不存在 创建文件 
>
>   a+ 以附加方式打开可读可写的文件 若文件存在 则会在文件末尾进行数据写入 若文件不存在 创建文件
>
> 若以”a+”方式打开一个已存在的文件，原文件如果不存在，则创建，如果存
>
> 在则打开，并且将文件位置指针移到文件尾，可以在文件尾进行数据添加，也可以从文件
>
> 开头处进行读数，但文件位置指针不可移到文件头，不能进行重写操作。



## 8、下面关于#import和#include描述正确的是

> A  \#import和#include不可以混合使用
>
> B \#import只用于引用Objective-C的文件，#include只用于Ｃ和C++的文件
>
> C \#import和#include的使用效果完全相同
>
> D #import是#include的替代指令，防止重复引用

> D
>
> 在头文件中，#pragma once和#ifndef DEQUEZZY_H #define DEQUEZZY_H #endif  效果一致，都是为了防止头文件的重复引用



## 5/27号

## 1、函数fun的声明为int fun(int *p[4]),以下哪个变量可以作为fun的合法参数（）

> A  int a\[4\]\[4\];
>
> B  int **a;
>
> C int \**a\[4]
>
> D int \(*a)\[4];

> 正确答案：B
>
> 你的答案：A
>
> 对于A答案来说，a\[4]\[4] = \(*a\)\[4\]   与参数不符合

## 2、以下叙述中正确的是（）

> A  只能在函数体内定义变量，其他地方不允许定义变量
>
> B  常量的类型不能从字面形式上区分，需要根据类型名来决定
>
> C  预定义的标识符是C语言关键字的一种，不能另作它用
>
> D  整型常量和实型常量都是数值型常量

> 正确答案：D
>
> 你的答案：C
>
> 对于C来说，标识符就是你定义变量的哪个变量名，分为预定义标识符（如 printf ）和用户标识符（如 a）



## 3、下列程序的输出是（）

```C
#include <stdio.h>
int main(void) {
    int a[12] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}, *p[4], i;
    for (i = 0; i < 4; i++) p[i] = &a[i * 3];
    printf("%d\n", p[3][2]);
    return 0;
}
```

> A  上述程序有错误
>
> B  6
>
> C  8
>
> D  12

> 正确答案：D
>
> 你的答案：A
>
> int \*p\[4]: p 是指针数组, 数组内包含 4 个元素, 每个元素都是 int\* 类型. 
>
>   p\[3] = &a\[9\], 即第 3 个元素是指向 a\[9] 的 
>
>   p\[3]\[2] = p\[3]+2, p[3] 是 int* 类型, 偏移 2 个单位后指向 a[11]

## 4、<a name="文件读写">文件读写</a>

### 文件模式
"r"：只读模式打开文件，文件必须存在。
"w"：只写模式打开文件，文件不存在则创建，存在则清空。
"a"：追加模式打开文件，文件不存在则创建，存在则在文件末尾追加。
"r+"：读/写模式打开文件，文件必须存在。
"w+"：读/写模式打开文件，文件不存在则创建，存在则清空。
"a+"：读/追加模式打开文件，文件不存在则创建，存在则在文件末尾追加。

### 二进制模式
在文件模式字符串中添加 "b" 表示以二进制模式打开文件。这些模式与上面的文本模式组合使用：

"rb"：只读模式以二进制方式打开文件。
"wb"：只写模式以二进制方式打开文件。
"ab"：追加模式以二进制方式打开文件。
"r+b" 或 "rb+"：读/写模式以二进制方式打开文件。
"w+b" 或 "wb+"：读/写模式以二进制方式打开文件。
"a+b" 或 "ab+"：读/追加模式以二进制方式打开文件。



## 5、正则表达式中，表示匹配非数字字符的字符是（）

> A  \b
>
> B  \d
>
> C  \B
>
> D  \D

> 正确答案：D
>
> 你的答案：A

| 元字符         | 描述                                                         |
| -------------- | ------------------------------------------------------------ |
| `\`            | 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\\n”匹配\n。“\n”匹配换行符。序列“\\\”匹配“\”而`\(`则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 |
| `^`            | 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，`^`也匹配“\n”或“\r”之后的位置。 |
| `$`            | 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，`$`也匹配“\n”或“\r”之前的位置。 |
| `*`            | 匹配前面的子表达式任意次。例如，`zo*`能匹配“z”，也能匹配“zo”以及“zoo”。`*`等价于`o{0,}` |
| `+`            | 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。`+`等价于`{1,}`。 |
| `?`            | 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。`?`等价于`{0,1}`。 |
| `{n}`          | `n`是一个非负整数。匹配确定的`n`次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个`o`。 |
| `{n,}`         | `n`是一个非负整数。至少匹配`n`次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有`o`。“o{1,}`等价于“o+”。“o{0,}”则等价于“o*”。 |
| `{n,m}`        | `m`和`n`均为非负整数，其中`n<=m`。最少匹配`n`次且最多匹配`m`次。例如，“o{1,3}”将匹配“fooooood”中的前三个`o`为一组，后三个`o`为一组。“o{0,1}`等价于“o?”。请注意在逗号和两个数之间不能有空格。 |
| `?`            | 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果`["oooo"]`，而“o+?”将尽可能少的匹配“o”，得到结果`['o', 'o', 'o', 'o']` |
| `.`            | 匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。 |
| `(pattern)`    | 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用`$0…$9`属性。要匹配圆括号字符，请使用“\(`或“\)”。 |
| `(?:pattern)`  | 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“( |
| `(?=pattern)`  | 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95 |
| `(?!pattern)`  | 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95 |
| `(?<=pattern)` | 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95 |
| `(?<!pattern)` | 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95 |
| `x|y`          | 匹配x或y。例如，“z                                           |
| `[xyz]`        | 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 |
| `[^xyz]`       | 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 |
| `[a-z]`        | 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身。 |
| `[^a-z]`       | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 |
| `\b`           | 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 |
| `\B`           | 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 |
| `\cx`          | 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 |
| `\d`           | 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持   |
| `\D`           | 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 |
| `\f`           | 匹配一个换页符。等价于\x0c和\cL。                            |
| `\n`           | 匹配一个换行符。等价于\x0a和\cJ。                            |
| `\r`           | 匹配一个回车符。等价于\x0d和\cM。                            |
| `\s`           | 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。 |
| `\S`           | 匹配任何可见字符。等价于[^ \f\n\r\t\v]。                     |
| `\t`           | 匹配一个制表符。等价于\x09和\cI。                            |
| `\v`           | 匹配一个垂直制表符。等价于\x0b和\cK。                        |
| `\w`           | 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。 |
| `\W`           | 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。                  |

## 6、在32位机器上，有如下代码：

```c
void func0(){
    char array[] = "abcdefg";
    printf("%d ", sizeof(array));  // 8
    const char *p = "abcdefg";  
    printf("%d ", sizeof(p));  // 4
}
void func1(char p[10])
{
    printf("%d ", sizeof(p));  // 4
}
void func2(char (&p)[10])
{
    printf("%d ", sizeof(p));  // 10
}
int main()
{
    char p[10] = "hello";
    func0();
    func1(p);
    func2(p);
    printf("%d ", sizeof(char[2])); // 2 
    printf("%d ", sizeof(char &)); // 1
    return 0;
}
```

> A  8 4 4 10 2 1
>
> B  4 4 4 10 4 1
>
> C  8 4 4 10 2 4
>
> D  8 4 4 4 2 1
>
> E  8 4 4 10 4 4
>
> F  以上答案都不对

> 正确答案：A
>
> 你的答案：D

```c

void func2(char (&p)[10])
{
    printf("%d ", sizeof(p));  // 10
}
// p是一个对数组的引用，引用保持数组的属性。因此sizeof(p)是数组的大小，这里是10。
```

```c
printf("%d ", sizeof(char[2])); // char[2]是一个大小为2的字符数组类型，结果是2。
printf("%d ", sizeof(char &));  // char &是字符的引用，引用的大小是其所引用对象的大小，sizeof(char)是1。
```

## 7、以下多线程对int型变量x的操作，哪几个需要进行同步（）

> A  x=y
>
> B  ++x
>
> C  x=1
>
> D   x++

> 正确答案：ABD
>
> 你的答案：ABCD
>
> 在多线程环境中，对共享变量的访问如果不是原子的，就需要进行同步,对于A由于y是变量，所以需要加锁，对于C来说x是常量，不会变化，所以不需要



# 6/1号

## 1、以下描述中正确的是（ ）

> A  由于do-while循环中循环体语句只能是一条可执行语句，所以循环体内不能使用复合语句
>
> B  do-while循环由do开始，用while结束，在while(表达式)后面不能写分号
>
> C  在do-while循环体中，不一定要有能使while后面表达式的值变为零("假")的操作
>
> D  do-while循环中，根据情况可以省略while

> 答案：C
>
> 对于A 可以使用复合语句，对于B do while后面必须使用分号
>
> C中while(1)但是可以在里面写break  do-while是一个整体



## 2、下面程序的输出结果是（）

```c
#include<iostream>
using namespace std;
class ClassA {
    friend long fun (ClassA a) {
        if (a.i < 2) return 1;
        return a.i * fun(ClassA(a.i-1));
    }
public:
    ClassA(long a) { i = a; }
private:
    long i;
};
 
int main() {
    int sum = 0;
    for (int i = 0; i < 4; i++) {
        sum += fun(ClassA(i));
    }
    cout << sum;
}
```

> 答案：10



## 3、关于局部变量和全局变量，下列说法错误的是（）

> A  c语言中根据变量的作用域不同，分为局部变量和全局变量。
>
> B  在函数内部定义的变量和复合语句里定义的变量，都是局部变量。
>
> C  在所有函数外定义的变量是全局变量，其有效范围从定义处至源文件结束。
>
> D  在全局变量定义之前是无法引用全局变量的。

> 答案：D
>
> 若在全局变量定义处之前的函数想引用该全局变量，则需要在函数中用关键字extern作外部变量声明。全局变量在程序运行前就已经被分配了内存空间，定义前就能调用

![img](https://uploadfiles.nowcoder.com/images/20220317/921129944_1647483587485/4E2F71714BECC0969BB551E91BCD7400)



## 4、以下叙述中正确的是（）

> A  使用typedef说明新类型名时，其格式是： typedef 新类型名 原类型名;
>
> B  在程序中，允许用typedef来说明一种新的类型名
>
> C  使用typedef 说明新类型名时，后面不能加分号
>
> D  在使用typedef改变原类型的名称后，只能使用新的类型名

> 答案：B
>
> A 选项错误，格式：typedef 原类型名 新类型名;
> B 选项正确
> C 选项错误，后面要加分号
> D 选项错误，新的类型名和原类型名都可以使用

## 5、在调用函数时，如果实参是简单变量（内置类型例如int），它与对应形参之间的数据传递方式是 ________ （ ）

> A  地址传递
>
> B  单向值传递
>
> C  由实参传给形参，再由形参传回实参
>
> D  传递方式由用户指定

> 正确答案：D
>
> 你的答案：B
>
> 仔细读题

## 6、在x86的机器上执行：请问b是多少

```c
int a = 0xabcd1234; 
char b = ((char*)&a)[0];
```

> A  0xa
>
> B  0x4
>
> C  0xab
>
> D  0x34

> 正确答案：D
>
> 你的答案：A

> x86是小端存储，即高位存储在高地址，低位存储在低地址。 int a = 0xabcd1234; 内存中 ab  cd  12  34，b作为一个char，右边表达式指针指向为0x34.       高  -->    低



## 7、请问运行Test 函数会有什么样的结果？

```c
char* getmemory(void){
    char p[]= " hello world";
    return p;
}
void test(void){
    char *str=NULL;
    str=getmemory(); printf(str);
}
```

> A  出错
>
> B  输出"hello world"
>
> C  输出空""
>
> D  输出乱码

> 正确答案：D
>
> 你的答案：A
>
> getmemory 返回的指针，是内部变量， 调用之后会被回收。 所以输出是不确定的。如果使用char *p在编译时就将字符串放到了常量区,字 符串字面量在程序的生命周期内存在于静态存储区，并且其指针在函数返回后仍然有效



# 6/2号

## 1、在声明类时，下面的说法正确的是（）

> A  可以在类的声明中给数据成员赋初值
>
> B  数据成员的数据类型可以是register
>
> C  private、public、protected可以按照任意顺序出现。
>
> D  没有用private、public、protected定义的数据成员是公有成员
>
> 正确答案：AC
> 你的答案：BC
>
> 解析：C++中没有限定这个几个关键词的出现顺序，但是没有用这几个关键词限定的数据成员是私有成员
>
> 对于在类的声明中给数据成员赋值，对于非静态成员可以直接赋值，而对于静态成员，一般要求类内生成类外定义，但是如果这个静态成员被const修饰就可以在类内定义的时候赋值。

```c
class MyClass {
public:
    int x = 0;
    double y = 3.14;
};

```

```c
class MyClass {
public:
    static int s_value;
};

int MyClass::s_value = 1; // 在类外定义并初始化

```

```c
class MyClass {
public:
    static const int a = 0; // 合法，const 限定的整型
    // static const float b = 3.14; // 非法，浮点型不能在类内初始化
    // static int c = 1; // 非法，非 const 的静态成员不能在类内初始化
};

```



## 2、以下函数中，和其他函数不属于一类的是____。

> A  read
> B  pread
> C  write
> D  pwrite
> E  fseek
> F  lseek

> 正确答案：E
> 你的答案：F
>
> - `read`、`pread`、`write`、`pwrite`、`lseek` 是用于文件描述符的系统调用函数，主要用于低级别的文件操作。它们通常在 POSIX 标准中定义，用于直接与操作系统内核进行交互。
>
>   - `read`：从文件描述符中读取数据。
>   - `pread`：从指定偏移位置的文件描述符中读取数据，而不改变文件指针。
>   - `write`：向文件描述符中写入数据。
>   - `pwrite`：向指定偏移位置的文件描述符中写入数据，而不改变文件指针。
>   - `lseek`：在文件描述符中移动文件指针的位置。
>
> - `fseek` 是一个 C 标准库函数，用于对文件流（FILE*）进行操作。它在高层次的标准 I/O 库中使用，与标准库的文件指针 `FILE*` 进行交互，而不是直接操作文件描述符。
>
>   - `fseek`：在文件流中移动文件指针的位置。
>

## 3、下列关于C/C++的宏定义的说法中，不正确的是：

> A 宏定义的常量更容易理解，如果可以使用宏定义常量的话，要避免使用 const常量
>
> B 宏的嵌套定义过多会影响程序的可读性，而且很容易出错
>
> C 相对于函数调用，宏定义可以提高程序的运行效率
>
> D 宏定义不检查参数正确性，这样会有安全隐患

> 正确答案：A
> 你的答案：B
>
> 解析：要尽量使用const来修饰，这样在你出现错误的时候能够快速看到，假设你没有定义这个变量，对于define来说，他会出现一个莫名其妙的错误，而不好检查这个错误所在位置。



## 4、下面有关C++的类和C里面的struct的描述，正确的有？

> A  在C++中，来自class的继承默认按照private继承处理，来自struct的继承默认按照public继承处理
> B  class的成员默认是private权限，struct默认是public权限
> C  c里面的struct只是变量的聚合体，struct不能有函数
> D  c++的struct可有构造和析构函数

>正确答案：ABCD
>你的答案：ABD



## 5、下列程序段的输出结果为（ ）

```c
float k = 0.8567;
printf("%06.1f%%", k*100);
```

> A  0085.6%%
> B  0085.7%
> C  0085.6%
> D  .857

> 答案：B
>
> 6是用六个位置，0是指第一个非零数字前用零填充，.1小数点后保留1位小数,%%是输出%
> 一般默认 取有效数字时 四舍五入，不足的补零 





# 6/3号

## 1、下列代码的输出是（）

```c
#include<stdio.h>
 
int main() {
    const char *c[] = {"HELLO", "NEW", "WORLD", "SAYHI"};
    const char **cp[] = {c + 3, c + 2, c + 1, c};
    const char ***cpp = cp;
    printf("%s,", **++cpp);
    printf("%s,", *--*++cpp + 3);
    printf("%s,", *cpp[-2] + 3);
    printf("%s\n", cpp[-1][-1] + 1);
    return 0;
}
```

> A  WORLD,LO,SAYHI,EW
> B  WORLD,LO,HI,NEW
> C  NEW,LO,SAYHI,EW
> D  WORLD,LO,HI,EW

> 答案：D

![指针计算](/img/指针计算.jpg)



## 2、关于C语言中的float，下面哪种说法正确的是 （）

> A  x的二次方大于等于0,对于float变量x总成立
> B  float 变量加法满足交换律
> C  条件0.9f == 0.9 的值为真
> D  条件9 == 0.9*10 的值为真

> 正确答案：A
>
> 解析：C/C++中浮点数由符号位、阶码和位数组成，其二进制并不直接对应浮点数的大小，因此浮点数不能进行位运算，编译器会报错。
>
> 对于B浮点数不满足加法和乘法的交换律，不满足加法的结合律。
>
> C和D错误，浮点数存在误差，直接比较大小王阿旺不符合预期的结果；通常引入一个比要求精度要小几个数量级的实数来帮助比较大小。

## 3、有定义语句：则正确的输入语句是______。

```c
int b;
char c[10];
```

> A  scanf("%d%s",&b,&c);
> B  scanf("%d%s",&b,c);
> C  scanf("%d%s",b,c);
> D  scanf("%d%s",b,&c);

> A、B
>
> 对于char c[10]来说，c和&c的意义不同，但是值相同，因此选AB



## 4、对结构体类型的变量的成员的访问，无论数据类型如何都可使用的运算符是（ ）
> A  .
> B  -
> C  *
> D  &

> 答案 A，对于结构体的访问，当他变为指针的时候，（*p）.  来访问



## 5、以下程序运行后的输出结果是（）

```c
int main() {
    FILE *fp;
    int i = 20, j = 30, k, n;
    fp = fopen("d1.dat", "w");
    fprintf(fp, "%d\n", i);
    fprintf(fp, "%d\n", j);
    fclose(fp);
    fp = fopen("d1.dat", "r");
    fscanf(fp, "%d%d", &k, &n);
    printf("%d,%d\n", k, n);
    fclose(fp);
}
```

> A  20,30
> B  20,50
> C  30,50
> D  30,20

> 答案：A
>
> 该程序的功能就是将两个整型数i和j的值通过fprintf 函数将它们转换成字符串的形式（包含\n）写入到文件d1.dat中，然后通过fscanf函数从文件d1.dat中格式化读出到变量k和n中，所以k的值将是20，n的值将是30。故选择答案是A。



# 6/4号

## 1、以下程序的输出是（）

```C
union myun {
    struct { int x, y, z;} u;
    int k;
} a;
int main()
{
    a.u.x = 4;
    a.u.y = 5;
    a.u.z = 6;
    a.k = 0;
    printf("%d\n", a.u.x);
}
```

> A  4
> B  5
> C  6
> D  0

> 答案：D
>
> 变量。是一联合体变量，其包含两个成员：一个是结构体类型成员u，一个
>
> 是整型变量k，联合体变量a所占内存大小由结构体成员u来决定，k与结构体成员u的成
>
> 员x共用同一内存单元，所以执行a.k=0相当于执行a.u.x=0，故正确答案是D

## 2、对于基类型相同的两个指针变量之间，不能进行的运算是（）

> A  <
> B  =
> C  +
> D  -

> C语言中，对于基类型相同的两个指针变量之间可以进行大小比较、赋值及
>
> 减法运算，但加法运算没有意义。所以应选择C。

## 3、（）是用同一个名字引用的相关变量的集合。

> A  结构
> B  联合
> C  变量
> D  枚举

> 共用体关键字 union   共用体是不同变量共享同一段存储空间。共用体内所有变量共享同一段存储空间，由最大的变量决定存储空间的大小。 
>
>   结构体关键字  struct  结构体是同一名字下  有不同数据类型 。aa.a, aa.b 是同一名字下的不同变量，有着各自的存储空间。
>

## 4、对于c/c++的下列运算符中，能够被重载的是（）

> A  &&
> B  !=
> C  .
> D  ->

> 除了类属关系运算符"."、成员指针运算符".*"、作用域运算符"::"、sizeof运算符和三目运算符"?:"以外，C++中的所有运算符都可以重载 
>
>   但是=、()、[]、->这四个不能重载为类的友元函数,只能重载为普通的成员函数

 

# 6/8号

## 1、以下变量分配在BSS段的是（）

```c
char s1[100];
int s2 = 0;
static int s3 = 0;
 
int main() {
    char s4[100];
}
```

> A  s1
> B  s2
> C  s3
> D s4

> 正确答案：A
> 你的答案：C
>
> 解析：BSS段是指存放**未初始化的全局变量**的内存区域
>
> 数据段：通常用来指存放程序中**已经初始化的全局变量**的内存区域，static意味着在数据段中存放变量
>
> 代码段：通常指用来存放代码的一段内存区域
>
> 堆：存放进程运行中被动态分配的内存段，大小并不固定，可动态扩张或缩减
>
> 栈：存放程序的局部变量

## 2、下面的程序执行输出几个hello？

```c
#include<stdio.h>
#include <unistd.h>
int main( ) {
    fork( );
    fork( );
    fork( );
    printf("hello\n");
    return 0;
}
```

> A  3
> B  4
> C  6
> D  8

> 正确答案：D  指数级增长
> 你的答案：A
>
> fork函数会在C语言中，`fork()` 是一个系统调用，用于创建一个新进程。新创建的进程称为子进程，它是调用`fork()`的进程（称为父进程）的副本。子进程从调用`fork()`的那一行代码开始执行，与父进程几乎完全相同，但它们有不同的进程ID (PID)。`fork()` 函数在父进程和子进程中返回不同的值，以便区分它们。
>
> 以下是`fork()` 的基本工作原理和它的返回值：
>
> - **父进程中**：`fork()` 返回子进程的PID。
> - **子进程中**：`fork()` 返回0。
> - **出错时**：`fork()` 返回 -1。

## 3、下列C程序执行后c输出结果为( )（32位）

```c
#include<stdio.h>
#include<stdlib.h>
void main()
{
　　int a = -3;
　　unsigned int b = 2;
　　long c = a + b;
　　printf("%ld\n", c);
}
```

> A  -1
> B  4294967295
> C  0x7FFFFFFF
> D  0xFFFFFFFF

> 无符号和有符号整数进行运算时，有符号整数会被提升为无符号整数。
>
> `int a = -3;` 定义了一个有符号整数 `a`，其值为 -3。
>
> `unsigned int b = 2;` 定义了一个无符号整数 `b`，其值为 2。
>
> 表达式 `a + b` 涉及一个有符号整数和一个无符号整数。
>
> 在C语言中，当一个有符号整数和一个无符号整数一起参与算术运算时，有符号整数会被转换为无符号整数进行运算。这是由于C语言的整数提升规则。
>
> 在32位系统上，有符号整数 `-3` 被解释为无符号整数 `4294967293`。
>
> 无符号整数运算：`4294967293 (unsigned int) + 2 (unsigned int) = 4294967295`。
>
> 结果 `4294967295` 是无符号整数。
>
> `long` 类型的大小和有符号性在不同系统上可能有所不同，但通常它是64位的有符号整数。
>
> 结果 `4294967295` 被解释为 `long` 类型的值。这时，这个值仍然是 `4294967295`，并且它可以被解释为有符号数 `-1`。












































































































# 外链知识（设置一个锚点能够跳转到这个位置）

## <a name="析构函数">析构函数</a>



## <a name="函数重载">函数重载</a>



## <a name="友元函数 ">友元函数 </a>

* 它允许在类的外部定义的函数能够访问类的私有成员变量和私有成员函数，以及保护成员。
* 友元函数可以直接访问类的私有成员，包括私有成员变量和私有成员函数。这样可以增加函数与类的交互性，但也破坏了封装性。
* 友元函数允许某些函数具有特权，能够访问类的私有成员，这样可以在需要时控制对私有成员的访问。
* 在运算符重载的场景中，友元函数常常用于实现对运算符的重载，因为运算符重载函数通常需要访问类的私有成员。

```c
#include <iostream>
using namespace std;

class MyClass {
private:
    int privateVar;

public:
    MyClass(int value) : privateVar(value) {}

    // 声明友元函数
    friend void friendFunction(MyClass obj);
};

// 定义友元函数，可以访问类的私有成员
void friendFunction(MyClass obj) {
    cout << "Value of privateVar: " << obj.privateVar << endl;
}

int main() {
    MyClass obj(42);
    friendFunction(obj);
    return 0;
}

```



## <a name="内联函数 ">内联函数 </a>

> 内联函数（Inline Function）是C++中的一种特殊函数，它在编译时请求编译器将函数的调用直接替换为函数体代码，以减少函数调用的开销。通过内联函数，可以提高程序的运行效率，特别是对于频繁调用的小函数。 

内联函数（Inline Function）是C++中的一种特殊函数，它在编译时请求编译器将函数的调用直接替换为函数体代码，以减少函数调用的开销。通过内联函数，可以提高程序的运行效率，特别是对于频繁调用的小函数。

### 内联函数的特点

1. **减少函数调用开销**：
   - 函数调用通常涉及参数传递、堆栈操作等开销。内联函数通过在调用处直接插入函数体代码，省去了这些开销。

2. **可能增加代码大小**：
   - 如果内联函数体较大或频繁调用，会导致生成的可执行代码体积增大。这是因为每次调用内联函数时，都会插入函数体代码。

3. **编译器的建议**：
   - `inline` 关键字只是向编译器提出一个建议，并不强制编译器必须内联。编译器会根据函数的复杂性和其他因素决定是否内联。

### 如何定义内联函数

使用 `inline` 关键字可以建议编译器将函数定义为内联函数。内联函数通常在类定义中声明和定义，或者在类定义之外的函数定义中使用 `inline` 关键字。

### 示例代码

```cpp
#include <iostream>

// 内联函数的定义
inline int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 5, y = 3;
    std::cout << "Sum: " << add(x, y) << std::endl;
    return 0;
}
```

在这个例子中，`add` 函数被定义为内联函数。当编译器处理 `add(x, y)` 调用时，它会将 `add` 函数的代码插入到调用处，从而避免了常规函数调用的开销。

### 类中的内联函数

在类中，可以在类定义内直接定义函数，这些函数会默认被视为内联函数。

```cpp
class MyClass {
public:
    // 内联成员函数
    int multiply(int a, int b) {
        return a * b;
    }
};

int main() {
    MyClass obj;
    std::cout << "Product: " << obj.multiply(4, 5) << std::endl;
    return 0;
}
```

在这个例子中，`multiply` 函数是在类定义内定义的，因此它是一个内联函数。

### 注意事项

- 内联函数适用于短小且频繁调用的函数，例如访问器（getter）和设置器（setter）。
- 对于复杂或包含循环、大量代码的函数，不建议使用 `inline`，因为这可能导致代码膨胀，反而降低性能。
- 虽然使用 `inline` 关键字可以建议编译器进行内联优化，但最终是否内联由编译器决定。

内联函数通过减少函数调用的开销，提高了程序的执行效率，但需要合理使用，以避免代码膨胀带来的负面影响。









## <a name="常函数">常函数</a>

常函数（const member function）是成员函数的一种，它承诺不修改对象的状态。常函数在声明和定义时都需要使用 `const` 关键字进行修饰。这样可以确保在常函数内部不会修改任何成员变量。 

使用常函数有几个重要的原因：

1. **保证不修改对象状态**：常函数可以防止无意中修改对象的状态，这有助于保持对象的一致性。
2. **提高代码可读性**：通过将某些函数声明为常函数，程序员可以更明确地表达函数的意图，即这些函数不会修改对象。
3. **允许常对象调用**：只有常函数才能被常对象（const objects）调用。

常对象：const MyClass obj;  // 常对象 

### 重点总结

1. **声明常函数**：在成员函数声明和定义的结尾处加上 `const` 关键字。
2. **常对象**：常对象只能调用常函数，不能调用非常函数。
3. **常函数的限制**：常函数中不能修改类的成员变量，除非它们是 `mutable` 修饰的。

## <a name="内存布局">内存布局</a>

栈（Stack）：由编译器自动管理，用于存放函数的局部变量、函数参数、返回地址等，具有动态特性，内存地址从高地址向低地址增长。
堆（Heap）：由new分配的内存块，由程序员释放（编译器不管），一般一个new与一个delete对应，一个new[]与一个delete[]对应。如果程序员没有释放掉，资源将由操作系统在程序结束后自动回收。 用于动态内存分配，如通过malloc、calloc、realloc函数分配的内存）

数据段（Data Segment）：包括已经初始化的全局变量和静态变量，内存地址固定。

BSS段（BSS(Block Started by Symbol) Segment）：包括未初始化的全局变量和静态变量，在程序开始执行前，这个段会被操作系统清零

代码段（Text Segment）：用于存放程序的可执行指令，内存地址固定



## <a name="局部静态变量">局部静态变量</a>

> 局部静态变量是声明在函数内部，但使用static关键字修饰的变量。它们具有以下特点：
>
> * 存储位置: 尽管他是一个静态变量，但是他和全局变量存储在一个数据段或者BSS段
> * 生命周期：局部静态变量的生命周期是整个程序运行期间。它们在第一次调用定义它们的函数时初始化，并在程序终止时销毁。
> * 作用域：它们的作用域仅限于定义它们的函数。尽管它们的值在函数的多次调用之间保持不变，但它们不能被函数外部的代码直接访问。
>
> 初始化
>
> * 默认初始化：如果局部静态变量没有显式初始化，则会被初始化为零（对于基本数据类型）。
> * 显式初始化：可以在定义局部静态变量时显式地给它们赋初始值。这个初始化只在变量第一次被创建时进行一次。

## <a name="sizeof">sizeof和strlen</a>

| 特点         | `sizeof`                   | `strlen`                   |
| ------------ | -------------------------- | -------------------------- |
| 计算内容     | 数据类型或对象占用的字节数 | 以 `\0` 结尾的字符串的长度 |
| 计算时机     | 编译时                     | 运行时                     |
| 作用范围     | 任何数据类型               | 仅限以 `\0` 结尾的字符串   |
| 包括 `\0` 吗 | 包括（如果是字符数组）     | 不包括                     |



## <a name="指针数组">指针数组和数组指针</a>

### 指针数组

> 指针数组是一个数组，其中每个元素都是一个指针。这个数组可以存储多个指针，通常指向相同类型的数据。 

```
tpye *array[size]
```

```
#include <stdio.h>

int main() {
    int a = 1, b = 2, c = 3;
    int *ptrArray[3]; // 定义一个指针数组，包含3个指向整数的指针

    ptrArray[0] = &a;
    ptrArray[1] = &b;
    ptrArray[2] = &c;

    for (int i = 0; i < 3; i++) {
        printf("Value at ptrArray[%d] = %d\n", i, *ptrArray[i]);
    }

    return 0;
}

```







### 数组指针

> 数组指针是一个指向数组的指针。这意味着指针本身指向一个数组，并且该数组的元素类型和大小是已知的。 

```
type (*pointerName)[size];
```

```
#include <stdio.h>

int main() {
    int array[5] = {1, 2, 3, 4, 5};
    int (*arrayPtr)[5]; // 定义一个指向包含5个整数的数组的指针

    arrayPtr = &array;

    for (int i = 0; i < 5; i++) {
        printf("Value at array[%d] = %d\n", i, (*arrayPtr)[i]);
    }

    return 0;
}

```







## <a name="指针函数">指针函数和函数指针</a>

### 函数指针

> 函数指针是指指向一个函数的指针，可以通过这个指针完成对函数的调用

* 定义

```
type (*func)(parameter_list)
```

```C
#include <stdio.h>

// 定义一个函数
int add(int a, int b) {
    return a + b;
}

int main() {
    // 定义一个函数指针，指向返回int类型并接受两个int参数的函数
    int (*func_ptr)(int, int) = add;

    // 使用函数指针调用函数
    int result = func_ptr(3, 4);

    printf("Result: %d\n", result); // 输出: Result: 7

    return 0;
}

```



### 指针函数

> 指针函数是指一个函数的返回值是一个指针

* 定义

```C
return_type *function_name(parameter_list);
```

```
#include <stdio.h>

// 定义一个返回int指针的函数
int* find_max(int *a, int *b) {
    return (*a > *b) ? a : b;
}

int main() {
    int x = 5;
    int y = 10;

    // 调用指针函数
    int *max = find_max(&x, &y);

    printf("Max value: %d\n", *max); // 输出: Max value: 10

    return 0;
}
```





## <a name="指针常量">指针常量和常量指针</a>

它们的区别主要在于“谁是常量”，即指针本身是常量，还是指针指向的数据是常量。

**常量指针**

* 常量指针是指向常量数据的指针。通过常量指针，不能修改它所指向的对象的值。

* 声明方式：

```
const int *ptr;
int const *ptr;
```



**指针常量（Constant Pointer）**

* 指针常量是指针本身是常量。一旦初始化后，不能改变指针指向的地址，但可以通过指针修改指向的对象的值（前提是指向的对象不是常量）。
* 声明方式

```
int *const ptr;
```





## <a name="string">string.h</a>

### 字符串操作方法：

1、strcpy 和 strncpy

* strcpy 函数用于将源字符串复制到目标字符串中。

```
#include <stdio.h>
#include <string.h>

int main() {
    char src[] = "Hello, World!";
    char dest[50];

    strcpy(dest, src);
    printf("Destination: %s\n", dest); // 输出: Destination: Hello, World!

    return 0;
}
//注意：目标数组必须有足够的空间来存储源字符串及其末尾的空字符 \0。
```

* strncpy 函数是 strcpy 的安全版本，允许指定复制的最大字符数。
  * 如果源字符串长度大于指定的字符数，目标字符串不会自动加上空字符，需要手动添加

* strlen 函数用于计算字符串的长度（不包括末尾的空字符 \0）。

* strcmp 和 strncmp   用于比较字符串

* strcat和 strncat  
  * strcat 函数用于将源字符串追加到目标字符串的末尾。
* strchr 和 strrchr
  * strchr 函数用于在字符串中查找第一次出现的指定字符。
  * strrchr最后一次出现的位置
* strstr 查找子字符串第一次出现的位置





































































