## wxPython 简介

wxPython 是一个用于创建桌面 GUI 应用程序的跨平台工具包。 wxPython 的主要作者是 *Robin Dunn*。 借助wxPython，开发人员可以在 Windows，Mac 和各种 Unix 系统上创建应用程序。 wxPython 封装了 wxWidgets，而 wxWidgets 是一个成熟的跨平台 C ++ 库。 

## wxPython 模块

wxPython 由五个基本模块组成。

![img](/assets/modules.jpg)



Controls 模块：提供了图形应用程序中常见的 widgets。例如 Button、Toolbar 或 Notebook。Widgets 在 Windows 上叫做 controls。

Core 模块：由开发的基本中用到的基本类组成。这些类包括 Object 类，它是所有类的基类；Sizers，用于 widget 布局；Events；像 Point 和 Rectangle 这样的基本几何类。 

GDI 模块：The Graphics Device Interface，图形设备接口。是用于绘制 widgets 的一组类。

Misc 模块：包含各种其他类和模块功能。 这些类用于记录日志，应用程序配置，系统设置，显示或操纵杆。

Windows 模块：由形成应用程序的各种窗口组成，例如 面板 Panel，对话框 Dialog，框架 Frame 或滚动窗口 Scrolled Window。

## wxPython API

wxPython API 是一组方法和对象。 组件 Widgets 是 GUI 应用程序的重要组成部分。组件 Widgets 在 Windows 下被称作控件 controls。 我们大致可以将程序员分成两组：编写应用程序或库。 在我们的例子中，wxPython 是应用程序员用来编写应用程序的库。 从技术上讲，wxPython 是一个名为 wxWidgets 的 C ++ GUI API 的封装。 所以它不是一个本地 API; 即它不是直接用 Python 编写的。

在 wxPython 中，我们有很多组件。 这些可以分成一些逻辑组。

### 基本 Widgets

这些组件为派生组件提供基本功能。 他们被称为祖先 ancestors。 他们通常不直接使用。 

![img](/assets/base.jpg) 

### 顶层 Widgets

这些组件彼此独立存在。 

![img](/assets/toplevel.jpg)  

### Containers

容器 Containers 包含其他组件 Widgets。 

![img](/assets/containers.jpg) 

### 动态 Widgets

这些组件可以由用户编辑。 

![img](/assets/dynamic.jpg) 

### 静态 Static Widgets

这些组件显示信息。 它们不能由用户编辑。 

![img](/assets/staticwidgets.jpg) 

### 其他 Widgets

这些组件在应用程序中实现状态栏，工具栏和菜单栏。

![img](/assets/bars.jpg) 

### 继承关系

wxPython 中的组件 widgets 之间有特定的关系。 这种关系是通过继承来发展的。 继承是面向对象编程的关键部分。 组件形成一个层次结构。 组件可以继承其他组件的功能。现有的类被称为基类，父母或祖先。 继承我们的组件称为派生组件，子组件或后代。 

![img](/assets/inheritance.png) 

假设我们在应用程序中使用了一个按钮组件按钮构件继承自四个不同的基类。 最接近的类是 `wx.Control` 类。 按钮组件是一种小窗口。所有出现在屏幕上的组件都是窗口。 因此它们从 `wx.Window` 类继承而来。 有些 objects 是不可见的。 比如 sizers，设备上下文 device context  或 locale 对象。 也有可见的类，但它们不是窗口。 例如，颜色对象 a colour object，插入符号对象 caret object 或游标对象 cursor object。 并非所有的组件都是控件。 例如 `wx.Dialog` 不是一种控件。控件是放置在其他称为容器 Containers 的组件上的组件。 这就是为什么我们有一个单独的 `wx.Control` 基类。

每个窗口都能对事件做出反应。 按钮组件也是如此。 通过点击按钮，我们启动 `wx.EVT_COMMAND_BUTTON_CLICKED` 事件。 按钮组件通过 `wx.Window` 类继承 `wx.EvtHandler`。 每个对事件作出反应的组件都必须从 `wx.EvtHandler` 类继承。 最后，所有对象都从 `wx.Object` 类继承。




# First steps in wxPython

## 简单的例子

我们从一个非常简单的例子开始。 我们的第一个脚本只会显示一个小窗口。

它不会做太多。 我们将逐行分析脚本。

**simple.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import wx

app = wx.App()

frame = wx.Frame(None, title='Simple application')
frame.Show()

app.MainLoop()
```

讲解：

```python
import wx
```

这一行导入基本的 wxPython 模块。 即 core、controls、gdi、misc 和 windows。 从技术上讲，`wx` 是一个命名空间。 基本模块中的所有功能和对象都将以 `wx.` 开头 `wx.`  字首。

下一行代码将创建一个应用程序对象。 

```python
app = wx.App()
```

每个 wxPython 程序都必须有一个应用程序对象。 

```python
frame = wx.Frame(None, title='Simple application')
frame.Show()
```

这里我们创建一个 `wx.Frame` 对象。 `wx.Frame` 组件是一个重要的容器组件。 我们将在稍后详细分析这个组件。 `wx.Frame` 组件是其他组件的父组件。 它本身没有父母 parent。 如果我们为父参数 parent parameter 指定 `None` ，则表明我们的组件没有父母。 它是组件层次结构中的顶级组件。在我们创建了 `wx.Frame` 组件之后，我们必须调用 `Show()` 方法将其显示在屏幕上。 

```python
app.MainLoop()
```

最后一行进入主循环。主循环是一个无限循环。它捕获和分发我们应用程序生命周期中存在的所有事件。

这是一个非常简单的例子。尽管这个简单，我们可以用这个窗口做很多事情。 我们可以调整窗口大小，最大限度地缩小窗口大小。这个功能需要编写很多代码。 所有这些都是隐藏的，并由 wxPython 工具箱默认提供。没有理由重新发明轮子。

![Simple example](/assets/simple.png)

## wx.Frame

wx.Frame 组件是 wxPython 中最重要的组件之一。它是一个容器组件。这意味着它可以包含其他组件。实际上它可以包含任何不是框架 frame 或对话框 dialog 的窗口。 `wx.Frame` 包含一个标题栏 title bar，边框 borders 和一个中央容器区域 central container area。标题栏和边框是可选的。他们可以通过各种标志 flags 去除。

`wx.Frame` 具有以下构造函数：

展示形式：`类型 参数名=默认值`

```python
wx.Frame(wx.Window parent, int id=-1, string title='', wx.Point pos=wx.DefaultPosition, 
    wx.Size size=wx.DefaultSize, style=wx.DEFAULT_FRAME_STYLE, string name="frame")
```

构造函数有七个参数。第一个参数没有默认值。其他六个参数有。

### wx.DEFAULT_FRAME_STYLE

`wx.DEFAULT_FRAME_STYLE` 是一组默认标志 flags： `wx.MINIMIZE_BOX` | `wx.MAXIMIZE_BOX` | `wx.RESIZE_BORDER` |`wx.SYSTEM_MENU` | `wx.CAPTION` | `wx.CLOSE_BOX` | `wx.CLIP_CHILDREN` 。通过组合各种样式，我们可以改变 `wx.Frame` 组件的样式。

#### 默认

具备所有风格属性

```python
import wx

app = wx.App()
frame = wx.Frame(None)
frame.Show(True)

app.MainLoop()
```

![1527417412183](/assets/1527417412183.png)

#### wx.MINIMIZE_BOX

![1527417584346](/assets/1527417584346.png)

#### wx.RESIZE_BORDER

可以伸缩

![1527417657992](/assets/1527417657992.png)

这些属性单独使用其实看不出效果，一般是组合使用

#### 组合

**no_minimize.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
 
# no_minimize.py

import wx

app = wx.App()
frame = wx.Frame(None, style=wx.MAXIMIZE_BOX | wx.RESIZE_BORDER
	| wx.SYSTEM_MENU | wx.CAPTION |	 wx.CLOSE_BOX)
frame.Show(True)

app.MainLoop()
```

我们的目的是显示一个没有最小化框的窗口。 所以我们没有在 style 参数中指定这个标志。 

## 大小和位置

我们可以通过两种方式指定应用程序的大小：在构造函数中使用 size 参数，或者我们可以调用 `SetSize()` 方法。 

**set_size.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# set_size.py

import wx


class Example(wx.Frame):
    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title,
            size=(350, 250))


def main():
    app = wx.App()
    ex = Example(None, title='Sizing')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在这个例子中，应用程序的大小为 250 x 200 像素。 

```python
def __init__(self, parent, title):
    super(Example, self).__init__(parent, title=title, 
        size=(350, 250))
```

在构造函数中，我们将 `wx.Frame` 组件的宽度设置为 350 像素。 组件的高度为 250 像素。

同样，我们可以将我们的应用程序放置在屏幕上。默认情况下，窗口放置在屏幕的左上角。但是在不同的操作系统平台甚至窗口管理器上它可能不同。一些窗口管理器自己放置应用程序窗。它们中的一些还做了一些优化，让窗口不重叠。程序员可以通过编程来定位窗口。我们已经在我们的 `wx.Frame` 组件的构造函数中看到了一个 `pos` 参数。通过提供非默认值，我们可以自己控制位置。

| 方法                                            | 描述                     |
| ----------------------------------------------- | ------------------------ |
| `Move(wx.Point point)`                          | 移动一个窗口到指定的位置 |
| `MoveXY(int x, int y)`                          | 移动一个窗口到指定的位置 |
| `SetPosition(wx.Point point)`                   | 设置窗口的位置           |
| `SetDimensions(x, y, width, height, sizeFlags)` | 设置窗口的位置和大小     |

有几种方法可以做到这一点。 

**moving.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# moving.py

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title,
            size=(300, 200))

        self.Move((800, 250))


def  main():

    app = wx.App()
    ex = Example(None, title='Moving')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

有一种特殊情况，我们可能希望我们的窗口最大化显示。在这种情况下，窗口位于 (0, 0) 并占据整个屏幕。wxPython 内部计算屏幕坐标。为了最大化我们的 `wx.Frame`，我们调用 `Maximize()` 方法。 

## Centering on the screen

如果我们想要将我们的应用程序居中在屏幕上，wxPython 有一个方便的方法。Centre()` 方法将窗口置于屏幕中央。无需计算屏幕的宽度和高度。只需调用该方法即可。 

**centering.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# centering.py

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title,
            size=(300, 200))

        self.Centre()


def main():

    app = wx.App()
    ex = Example(None, title='Centering')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在这个例子中，我们在屏幕上居中放置一个小窗口。 

```python
self.Centre()
```

`Centre()` 方法将窗口在屏幕上居中。

在本章中，我们在 wxPython 中创建了一些简单的代码示例。






# Menus and toolbars

GUI 应用程序中的一个常见部分是菜单栏。菜单栏由称为 menus 的对象组成。顶层菜单在菜单栏上有自己的标签 labels。菜单有菜单项 menu items。菜单项是在应用程序内部执行特定操作的命令。菜单也可以有子菜单 submenus，它们有自己的菜单项。在 wxPython 中有三个类用于创建菜单栏 menubars：`wx.MenuBar`，`wx.Menu` 和 `wx.MenuItem`。

## 简单的菜单

在我们的第一个例子中，我们将创建一个菜单文件。菜单将只有一个菜单项。 通过选择菜单项目让应用程序退出。 

**simple_menu.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

This example shows a simple menu.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        menubar = wx.MenuBar()
        fileMenu = wx.Menu()
        fileItem = fileMenu.Append(wx.ID_EXIT, 'Quit', 'Quit application')
        menubar.Append(fileMenu, '&File')
        self.SetMenuBar(menubar)

        self.Bind(wx.EVT_MENU, self.OnQuit, fileItem)

        self.SetSize((300, 200))
        self.SetTitle('Simple menu')
        self.Centre()

    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

这是一个最小菜单栏功能的小例子。 

```python
menubar = wx.MenuBar()
```

首先我们创建一个菜单栏对象。 

```python
fileMenu = wx.Menu()
```

接下来我们创建一个菜单对象。 

```python
fileItem = fileMenu.Append(wx.ID_EXIT, 'Quit', 'Quit application')
```

我们将菜单项追加到菜单对象中。 第一个参数是菜单项的 ID。 标准 id 会自动添加图标和快捷键，在我们的例子，是 Ctrl + Q（然而译者我用的 Windows 并没有生成图标和快捷键）。 第二个参数是菜单项的名称。 最后一个参数定义了选择菜单项时的简短帮助。 这里我们没有明确地创建一个 `wx.MenuItem` 。 它由幕后的 `Append()` 方法创建。 该方法返回创建的菜单项  menu item。 该引用在稍后将用于绑定事件。 

```python
self.Bind(wx.EVT_MENU, self.OnQuit, fileItem)
```

我们将菜单项的 `wx.EVT_MENU` （菜单退出事件绑定器）绑定到自定义的 `OnQuit()` 方法。 该方法将关闭应用程序。

```python
menubar.Append(fileMenu, '&File')
self.SetMenuBar(menubar)
```

之后，我们将菜单添加到菜单栏中。& 符号创建一个加速键，& 后面的字符加下划线（Windows 无效，Ubuntu 上也没看到效果，鸡肋，可以去掉）。这样菜单可以通过 Alt + F 快捷键访问。 最后，我们调用 `SetMenuBar()` 方法。此方法属于 `wx.Frame` 组件。 它设置菜单栏。

![A simple menu example](/assets/simplemenu.png)

## 图标和快捷键

下一个例子与前一个例子基本相同。 这一次，我们手动创建一个 `wx.MenuItem` 。 

**icons_shortcuts.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example, we manually create
a menu item.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

APP_EXIT = 1


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        menubar = wx.MenuBar()
        fileMenu = wx.Menu()
        qmi = wx.MenuItem(fileMenu, APP_EXIT, '&Quit\tCtrl+Q')
        qmi.SetBitmap(wx.Bitmap('exit.png'))
        fileMenu.Append(qmi)

        self.Bind(wx.EVT_MENU, self.OnQuit, id=APP_EXIT)

        menubar.Append(fileMenu, '&File')
        self.SetMenuBar(menubar)

        self.SetSize((350, 250))
        self.SetTitle('Icons and shortcuts')
        self.Centre()
        
    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在这个例子中，我们创建了一个退出菜单项。 我们选择一个自定义图标和菜单项的快捷键。 

```python
qmi = wx.MenuItem(fileMenu, APP_EXIT, '&Quit\tCtrl+Q')
qmi.SetBitmap(wx.Bitmap('exit.png'))
fileMenu.Append(qmi)
```

我们创建一个 `wx.MenuItem` 对象。 & 符号指定一个加速键。 & 符号后面的字符加下划线（没啥用，去掉也不影响后面的快捷键）。实际的快捷键由字符组合定义。我们指定了 Ctrl + Q。 所以如果我们按 Ctrl + Q ，应用程序会关闭。我们在 & 符号和快捷方式之间放置了一个 tab 符。这样，我们设法在它们之间留出一些空间。要为菜单项提供图标，我们调用 `SetBitmap()` 方法，手动创建的菜单项通过调用 `AppendItem()` 方法附加到菜单。 

```python
self.Bind(wx.EVT_MENU, self.OnQuit, id=APP_EXIT)
```

当我们选择菜单项时，`OnQuit()` 方法被调用。 

![Icons and shortcuts](/assets/iconsshortcuts.png) 

## 子菜单和分隔符

每个菜单也可以有一个子菜单，这样我们可以将类似的命令放入组中。例如，它可以隐藏/显示各种工具栏（如个人栏，地址栏，状态栏或导航栏）到称为工具栏 toolbars 的子菜单 submenu 的命令。在菜单中，我们可以用分隔符分隔命令。这是一条简单的线路。通常的做法是使用单个分隔符来分隔诸如新建、打开、保存命令和打印、打印预览等命令。在我们的例子中，我们将看到，我们如何创建子菜单和菜单分隔符。 

**submenu.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example, we create a submenu and a menu
separator.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        menubar = wx.MenuBar()

        fileMenu = wx.Menu()
        fileMenu.Append(wx.ID_NEW, '&New')
        fileMenu.Append(wx.ID_OPEN, '&Open')
        fileMenu.Append(wx.ID_SAVE, '&Save')
        fileMenu.AppendSeparator()

        imp = wx.Menu()
        imp.Append(wx.ID_ANY, 'Import newsfeed list...')
        imp.Append(wx.ID_ANY, 'Import bookmarks...')
        imp.Append(wx.ID_ANY, 'Import mail...')

        fileMenu.Append(wx.ID_ANY, 'I&mport', imp)

        qmi = wx.MenuItem(fileMenu, wx.ID_EXIT, '&Quit\tCtrl+W')
        fileMenu.Append(qmi)

        self.Bind(wx.EVT_MENU, self.OnQuit, qmi)

        menubar.Append(fileMenu, '&File')
        self.SetMenuBar(menubar)

        self.SetSize((350, 250))
        self.SetTitle('Submenu')
        self.Centre()

    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在上面的例子中，我们创建了新建，打开和保存标准菜单项。 具有水平分隔符的子菜单。 子菜单还有三个菜单项。 

```python
fileMenu.Append(wx.ID_NEW, '&New')
fileMenu.Append(wx.ID_OPEN, '&Open')
fileMenu.Append(wx.ID_SAVE, '&Save')
```

这里我们有三个常用菜单项：New、Open、Save。

```python
fileMenu.AppendSeparator()
```

菜单分隔符 `AppendSeparator()` 方法添加。 

```python
imp = wx.Menu()
imp.Append(wx.ID_ANY, 'Import newsfeed list...')
imp.Append(wx.ID_ANY, 'Import bookmarks...')
imp.Append(wx.ID_ANY, 'Import mail...')

fileMenu.Append(wx.ID_ANY, 'I&mport', imp)
```

一个子菜单也是一个 `wx.Menu` 。菜单上附有三个菜单项。子菜单通过 `Append()` 方法附加到 File 菜单。 

![A submenu example](/assets/submenu.png) 

## 勾选菜单项 Check menu item

有下面几种菜单项

- normal item
- check item
- radio item

在下面的例子中，我们将演示检查菜单项。 检查菜单项在菜单中由勾号可视地表示。 

**checkmenu_item.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

This example creates a checked
menu item.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        menubar = wx.MenuBar()
        viewMenu = wx.Menu()

        self.shst = viewMenu.Append(wx.ID_ANY, 'Show statusbar',
            'Show Statusbar', kind=wx.ITEM_CHECK)
        self.shtl = viewMenu.Append(wx.ID_ANY, 'Show toolbar',
            'Show Toolbar', kind=wx.ITEM_CHECK)

        viewMenu.Check(self.shst.GetId(), True)
        viewMenu.Check(self.shtl.GetId(), True)

        self.Bind(wx.EVT_MENU, self.ToggleStatusBar, self.shst)
        self.Bind(wx.EVT_MENU, self.ToggleToolBar, self.shtl)

        menubar.Append(viewMenu, '&View')
        self.SetMenuBar(menubar)

        self.toolbar = self.CreateToolBar()
        self.toolbar.AddTool(1, '', wx.Bitmap('exit.png'))
        self.toolbar.Realize()

        self.statusbar = self.CreateStatusBar()
        self.statusbar.SetStatusText('Ready')

        self.SetSize((450, 350))
        self.SetTitle('Check menu item')
        self.Centre()


    def ToggleStatusBar(self, e):

        if self.shst.IsChecked():
            self.statusbar.Show()
        else:
            self.statusbar.Hide()

    def ToggleToolBar(self, e):

        if self.shtl.IsChecked():
            self.toolbar.Show()
        else:
            self.toolbar.Hide()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

我们有一个 viewMenu，上面有两个勾选的菜单项。两个菜单项将会显示或隐藏状态栏和工具栏。 

```python
self.shst = viewMenu.Append(wx.ID_ANY, 'Show statusbar', 
    'Show Statusbar', kind=wx.ITEM_CHECK)
self.shtl = viewMenu.Append(wx.ID_ANY, 'Show toolbar', 
    'Show Toolbar', kind=wx.ITEM_CHECK)
```

如果我们想添加一个勾选菜单项，我们为 `wx.ITEM_CHECK` 设置一个 `kind` 参数。默认参数是 `wx.ITEM_NORMAL`。 `Append()` 方法返回一个 `wx.MenuItem` 。 

```python
viewMenu.Check(self.shst.GetId(), True)
viewMenu.Check(self.shtl.GetId(), True)
```

当程序启动，状态栏和工具栏都可见。 所以我们用 `Check()` 方法检查两个项目。 

```python
def ToggleStatusBar(self, e):
    
    if self.shst.IsChecked():
        self.statusbar.Show()
    else:
        self.statusbar.Hide()
```

We show or hide the statusbar according to the state of the check menu item. We find out the state of the check menu item with the `IsChecked()` method. Same with toolbar.

我们根据勾选菜单项的状态显示或隐藏状态栏。 通过 `IsChecked()` 方法找到的菜单项的状态。工具栏同理。 

![Check menu item](/assets/checkmenuitem.png)

## 上下文菜单 Context menu

上下文菜单是在某种上下文条件下出现的命令列表。 例如，在 Firefox 网页浏览器中，当我们右击一个网页时，我们会得到一个上下文菜单。在上下文菜单处，我们可以重新加载页面，返回或查看页面源代码。如果我们点击一个工具栏，我们会得到另一个用于管理工具栏的上下文菜单。上下文菜单有时称为弹出式菜单。

**context_menu.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example, we create a context menu.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

class MyPopupMenu(wx.Menu):

    def __init__(self, parent):
        super(MyPopupMenu, self).__init__()

        self.parent = parent

        mmi = wx.MenuItem(self, wx.NewId(), 'Minimize')
        self.Append(mmi)
        self.Bind(wx.EVT_MENU, self.OnMinimize, mmi)

        cmi = wx.MenuItem(self, wx.NewId(), 'Close')
        self.Append(cmi)
        self.Bind(wx.EVT_MENU, self.OnClose, cmi)


    def OnMinimize(self, e):
        self.parent.Iconize()

    def OnClose(self, e):
        self.parent.Close()


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)

        self.SetSize((350, 250))
        self.SetTitle('Context menu')
        self.Centre()

    def OnRightDown(self, e):
        self.PopupMenu(MyPopupMenu(self), e.GetPosition())


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在这个例子中，我们为主窗口创建了一个上下文菜单。它有两个项目。 一个将最小化应用程序，另一个将终止它。

```python
class MyPopupMenu(wx.Menu):
    
    def __init__(self, parent):
        super(MyPopupMenu, self).__init__()
```

我们创建一个单独的 `wx.Menu` 类。 

```python
mmi = wx.MenuItem(self, wx.NewId(), 'Minimize')
self.Append(mmi)
self.Bind(wx.EVT_MENU, self.OnMinimize, mmi)
```

一个菜单项被创建并附加到上下文菜单。一个事件处理程序 event handler 绑定到此菜单项。 

```python
self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
```

如果我们右键点击框架 frame，我们调用 `OnRightDown()` 方法。 为此，我们使用 `wx.EVT_RIGHT_DOWN` 事件绑定程序 event binder。 

```python
def OnRightDown(self, e):
    self.PopupMenu(MyPopupMenu(self), e.GetPosition())
```

在 `OnRightDown()` 方法中，我们调用 `PopupMenu()` 方法，该方法显示上下文菜单。 第一个参数是要显示的菜单，第二个参数是上下文菜单出现的位置。上下文菜单出现在鼠标光标的位置。 为了获得实际的鼠标位置，我们调用提供的事件对象的 `GetPosition()` 方法。 

![Context menu](/assets/contextmenu.png) 

## 工具栏 Toolbars

菜单将我们可以在应用程序中使用的所有命令分组。工具栏提供了对最常用命令的快速访问。

要创建一个工具栏，我们调用框架组件 frame widget 的 `CreateToolBar()` 方法。

**toolbar.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

This example creates a simple toolbar.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        toolbar = self.CreateToolBar()
        qtool = toolbar.AddTool(wx.ID_ANY, 'Quit', wx.Bitmap('exit.png'))
        toolbar.Realize()

        self.Bind(wx.EVT_TOOL, self.OnQuit, qtool)

        self.SetSize((350, 250))
        self.SetTitle('Simple toolbar')
        self.Centre()

    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在我们的例子中，我们有一个带有一个工具的工具栏。 当我们点击它时，该工具将关闭应用程序。 

```python
toolbar = self.CreateToolBar()
```

我们创建一个工具栏。 默认情况下，工具栏是水平的，没有边框和显示。 

```python
qtool = toolbar.AddTool(wx.ID_ANY, 'Quit', wx.Bitmap('texit.png'))
```

要创建一个工具栏工具，我们调用 `AddTool()` 方法。第二个参数是工具的标签，第三个参数是工具的图像。请注意，标签 label 不可见，因为默认样式仅显示图标。 

```python
toolbar.Realize()
```

将我们的项目放到工具栏后，我们调用 `Realize()` 方法。 在 Linux 上调用此方法不是强制性的。 在 windows  上是必须的（不然不会添加工具）。 

```python
self.Bind(wx.EVT_TOOL, self.OnQuit, qtool)
```

要处理工具栏的事件，我们使用 `wx.EVT_TOOL` 事件绑定器。 

![Simple toolbar](/assets/simpletoolbar.png) 

如果我们想创建多个工具栏，我们必须以不同的方式处理。 

**toolbars.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

'''
ZetCode wxPython tutorial

In this example, we create two horizontal
toolbars.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
'''

import wx


class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        vbox = wx.BoxSizer(wx.VERTICAL)

        toolbar1 = wx.ToolBar(self)
        toolbar1.AddTool(wx.ID_ANY, '', wx.Bitmap('tnew.png'))
        toolbar1.AddTool(wx.ID_ANY, '', wx.Bitmap('topen.png'))
        toolbar1.AddTool(wx.ID_ANY, '', wx.Bitmap('tsave.png'))
        toolbar1.Realize()

        toolbar2 = wx.ToolBar(self)
        qtool = toolbar2.AddTool(wx.ID_EXIT, '', wx.Bitmap('texit.png'))
        toolbar2.Realize()

        vbox.Add(toolbar1, 0, wx.EXPAND)
        vbox.Add(toolbar2, 0, wx.EXPAND)

        self.Bind(wx.EVT_TOOL, self.OnQuit, qtool)

        self.SetSizer(vbox)

        self.SetSize((350, 250))
        self.SetTitle('Toolbars')
        self.Centre()

    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在上面的例子中，我们创建了两个水平工具栏。 

```python
toolbar1 = wx.ToolBar(self)
... 
toolbar2 = wx.ToolBar(self)
```

我们创建了两个工具栏对象，并把它们放入一个垂直的盒子里。 

![Toolbars](/assets/toolbars.png) 

## 启用和禁用 Enable & disable

下面的例子中，我们展示了如何启用和禁用工具栏按钮。 我们还添加到分隔线。

**undo_redo.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example, we create two horizontal
toolbars.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

class Example(wx.Frame):

    def __init__(self, *args, **kwargs):
        super(Example, self).__init__(*args, **kwargs)

        self.InitUI()

    def InitUI(self):

        self.count = 5

        self.toolbar = self.CreateToolBar()
        tundo = self.toolbar.AddTool(wx.ID_UNDO, '', wx.Bitmap('tundo.png'))
        tredo = self.toolbar.AddTool(wx.ID_REDO, '', wx.Bitmap('tredo.png'))
        self.toolbar.EnableTool(wx.ID_REDO, False)
        self.toolbar.AddSeparator()
        texit = self.toolbar.AddTool(wx.ID_EXIT, '', wx.Bitmap('texit.png'))
        self.toolbar.Realize()

        self.Bind(wx.EVT_TOOL, self.OnQuit, texit)
        self.Bind(wx.EVT_TOOL, self.OnUndo, tundo)
        self.Bind(wx.EVT_TOOL, self.OnRedo, tredo)

        self.SetSize((350, 250))
        self.SetTitle('Undo redo')
        self.Centre()

    def OnUndo(self, e):
        if self.count > 1 and self.count <= 5:
            self.count = self.count - 1

        if self.count == 1:
            self.toolbar.EnableTool(wx.ID_UNDO, False)

        if self.count == 4:
            self.toolbar.EnableTool(wx.ID_REDO, True)

    def OnRedo(self, e):
        if self.count < 5 and self.count >= 1:
            self.count = self.count + 1

        if self.count == 5:
            self.toolbar.EnableTool(wx.ID_REDO, False)

        if self.count == 2:
            self.toolbar.EnableTool(wx.ID_UNDO, True)


    def OnQuit(self, e):
        self.Close()


def main():

    app = wx.App()
    ex = Example(None)
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在我们的例子中，我们有三个工具栏按钮。一个按钮用于退出应用程序。 另外两个用于撤消和重做按钮。它们模拟应用程序中的 撤销/重做 功能。（有关实际示例，请参阅提示和技巧）我们有 4 次变化。 撤销/重做 按钮相应地进行启用和禁用。 

```python
self.toolbar.EnableTool(wx.ID_REDO, False)
self.toolbar.AddSeparator()
```

在开始时，重做按钮被禁用。我们通过调用 `EnableTool()` 方法来实现。我们可以在工具栏中创建一些逻辑组。 我们可以用分隔符分开各种按钮组。 为此，我们调用 `AddSeparator()` 方法。 

```python
def OnUndo(self, e):
    if self.count > 1 and self.count <= 5:
        self.count = self.count - 1

    if self.count == 1:
        self.toolbar.EnableTool(wx.ID_UNDO, False)

    if self.count == 4:
        self.toolbar.EnableTool(wx.ID_REDO, True)
```

我们模拟撤销和重做功能，有四次变化。 如果没有任何可撤消的内容，撤消按钮被禁用。 撤消第一次更改后，我们启用重做按钮。同样的逻辑适用于 `OnRedo()` 方法。 

![Undo redo](/assets/undoredo.png) 

在 wxPython 教程的这一部分，我们使用了菜单和工具栏。 


# Layout management in wxPython

一个典型的应用程序由各种组件组成。这些组件放置在容器组件中。 程序员必须管理应用程序的布局。这不是一件容易的事。 在 wxPython 中，可以使用绝对定位或使用 sizers 来布局组件。 

## 绝对定位

绝对定位：程序员以像素为单位指定组件的位置和大小。 绝对定位有几个缺点：

- 如果我们调整窗口的大小，组件的大小和位置不会随之改变。
- 应用在各种平台上看起来不同。
- 更改应用程序中的字体可能会破坏布局。
- 如果我们决定改变布局，我们必须完全重做我们的布局，这是乏味和耗时的。

我们可能会出现要使用绝对定位的情况。 例如，小的测试例子中。 但大多数情况下，在真实世界的程序中，程序员使用 sizers。

在我们的例子中，我们有一个简单的文本编辑框架。 如果我们调整窗口大小，`wx.TextCtrl` 的大小不会像我们预期的那样改变。

**absolute.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example, we lay out widgets using
absolute positioning.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title,
            size=(350, 300))

        self.InitUI()
        self.Centre()

    def InitUI(self):

        self.panel = wx.Panel(self)

        self.panel.SetBackgroundColour("gray")

        self.LoadImages()

        self.mincol.SetPosition((20, 20))
        self.bardejov.SetPosition((40, 160))
        self.rotunda.SetPosition((170, 50))


    def LoadImages(self):

        self.mincol = wx.StaticBitmap(self.panel, wx.ID_ANY,
            wx.Bitmap("mincol.jpg", wx.BITMAP_TYPE_ANY))

        self.bardejov = wx.StaticBitmap(self.panel, wx.ID_ANY,
            wx.Bitmap("bardejov.jpg", wx.BITMAP_TYPE_ANY))

        self.rotunda = wx.StaticBitmap(self.panel, wx.ID_ANY,
            wx.Bitmap("rotunda.jpg", wx.BITMAP_TYPE_ANY))


def main():

    app = wx.App()
    ex = Example(None, title='Absolute positioning')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在上面的例子中，我们使用绝对坐标定位三个图像。

```
self.mincol.SetPosition((20, 20))
```

使用 `SetPosition()` 方法，我们将图像放置在 x = 20，y = 20 坐标处。 

![absolute positioning 1](/assets/absolute.png) 

## 使用 sizer

Sizer 确实解决了我们提到的绝对定位问题。 wxPython 有以下 sizer： 

- wx.BoxSizer
- wx.StaticBoxSizer
- wx.GridSizer
- wx.FlexGridSizer
- wx.GridBagSizer

## wx.BoxSizer

`wx.BoxSizer` 使我们能够将多个组件放入行或列中。 我们可以将另一个 sizer 放入现有的 sizer 中。 这样我们可以创建非常复杂的布局。 

```python
 box = wx.BoxSizer(integer orient)  # orient：v. 确定自己的方向
 box.Add(wx.Window window, integer proportion=0, integer flag = 0, integer border = 0)
```

orient：方向可以是 `wx.HORIZONTAL` 或 `wx.HORIZONTAL`。 通过 `Add()` 方法将组件添加到 `wx.BoxSizer` 中。 为了理解它，我们需要看看它的参数。

proportion：比例参数定义组件在定义的方向上更改的比率。 假设我们有三个比例为 0, 1 和 2 的按钮，它们被添加到一个水平的 `wx.BoxSizer`。比例为 0 的按钮根本不会改变。比例为 2 的按钮在水平方向的变化是比例为 1 的 2 倍。

flag：使用 flag 参数，您可以进一步配置 `wx.BoxSizer` 中的组件的行为。

border：我们可以控制组件之间的外边距 border，以像素为单位在组件之间添加一些空间。

为了用到 border，我们需要定义 border 的边界 sides。我们可以将它们与 `|` 操作符相结合；例如 `wx.LEFT | wx.BOTTOM`。 我们可以在这些标志 flag 之间选择：

- wx.LEFT
- wx.RIGHT
- wx.BOTTOM
- wx.TOP
- wx.ALL

使用 `setSizer()` 方法将 sizer 设置为面板 panel。 

**border.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example we place a panel inside 
another panel.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()

    def InitUI(self):

        panel = wx.Panel(self)

        panel.SetBackgroundColour('#4f5049')
        vbox = wx.BoxSizer(wx.VERTICAL)

        midPan = wx.Panel(panel)
        midPan.SetBackgroundColour('#ededed')

        vbox.Add(midPan, wx.ID_ANY, wx.EXPAND | wx.ALL, 20)
        panel.SetSizer(vbox)


def main():

    app = wx.App()
    ex = Example(None, title='Border')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在上面的例子中，我们在面板 panel 周围放置了一些空间。 

```python
vbox.Add(midPan, wx.ID_ANY, wx.EXPAND | wx.ALL, 20)
```

`wx.ID_ANY`：代指任意 id。即不管是安装 installing 事件处理器 event handler，还是创建一个新的窗口，我们都不关心 id 的值。

在 `border.py` 我们在 `midPan` 面板上放置了 20px 的 border。 `wx.ALL` 将边框大小应用于所有四条边 sides。

如果我们使用 `wx.EXPAND` 标志 flag，我们的组件将使用分配给它的所有空间。最后，我们还可以定义我们的组件的对齐方式。我们用下列标志来做：

- wx.ALIGN_LEFT
- wx.ALIGN_RIGHT
- wx.ALIGN_TOP
- wx.ALIGN_BOTTOM
- wx.ALIGN_CENTER_VERTICAL
- wx.ALIGN_CENTER_HORIZONTAL
- wx.ALIGN_CENTER

![Border around a panel](/assets/border.png) 

## GoToClass example

在下面的例子中，我们介绍几个重要的想法。 

**goto_class.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
ZetCode wxPython tutorial

In this example we create a Go To class
layout with wx.BoxSizer.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()

    def InitUI(self):

        panel = wx.Panel(self)

        font = wx.SystemSettings.GetFont(wx.SYS_SYSTEM_FONT)

        font.SetPointSize(9)

        vbox = wx.BoxSizer(wx.VERTICAL)

        hbox1 = wx.BoxSizer(wx.HORIZONTAL)
        st1 = wx.StaticText(panel, label='Class Name')
        st1.SetFont(font)
        hbox1.Add(st1, flag=wx.RIGHT, border=8)
        tc = wx.TextCtrl(panel)
        hbox1.Add(tc, proportion=1)
        vbox.Add(hbox1, flag=wx.EXPAND|wx.LEFT|wx.RIGHT|wx.TOP, border=10)

        vbox.Add((-1, 10))

        hbox2 = wx.BoxSizer(wx.HORIZONTAL)
        st2 = wx.StaticText(panel, label='Matching Classes')
        st2.SetFont(font)
        hbox2.Add(st2)
        vbox.Add(hbox2, flag=wx.LEFT | wx.TOP, border=10)

        vbox.Add((-1, 10))

        hbox3 = wx.BoxSizer(wx.HORIZONTAL)
        tc2 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)
        hbox3.Add(tc2, proportion=1, flag=wx.EXPAND)
        vbox.Add(hbox3, proportion=1, flag=wx.LEFT|wx.RIGHT|wx.EXPAND,
            border=10)

        vbox.Add((-1, 25))

        hbox4 = wx.BoxSizer(wx.HORIZONTAL)
        cb1 = wx.CheckBox(panel, label='Case Sensitive')
        cb1.SetFont(font)
        hbox4.Add(cb1)
        cb2 = wx.CheckBox(panel, label='Nested Classes')
        cb2.SetFont(font)
        hbox4.Add(cb2, flag=wx.LEFT, border=10)
        cb3 = wx.CheckBox(panel, label='Non-Project classes')
        cb3.SetFont(font)
        hbox4.Add(cb3, flag=wx.LEFT, border=10)
        vbox.Add(hbox4, flag=wx.LEFT, border=10)

        vbox.Add((-1, 25))

        hbox5 = wx.BoxSizer(wx.HORIZONTAL)
        btn1 = wx.Button(panel, label='Ok', size=(70, 30))
        hbox5.Add(btn1)
        btn2 = wx.Button(panel, label='Close', size=(70, 30))
        hbox5.Add(btn2, flag=wx.LEFT|wx.BOTTOM, border=5)
        vbox.Add(hbox5, flag=wx.ALIGN_RIGHT|wx.RIGHT, border=10)

        panel.SetSizer(vbox)


def main():

    app = wx.App()
    ex = Example(None, title='Go To Class')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

布局很明了，我们创建一个 垂直 sizer，再把五个水平 sizers 放进去。 

```python
font = wx.SystemSettings.GetFont(wx.SYS_SYSTEM_FONT)

font.SetPointSize(9)
```

我们将字体大小更改为 9 像素。 

```python
vbox.Add(hbox3, proportion=1, flag=wx.LEFT|wx.RIGHT|wx.EXPAND, 
    border=10)

vbox.Add((-1, 25))
```

我们已经知道我们可以控制结合了 flag 参数和 border 参数的 widgets 之间的距离。但是有一个真正的约束。 在 `Add()` 方法中，我们只能为所有给定的边 sides 指定一个边框。 例子中，我们给右边和左边 10 个像素。我们不能给 25 px 的底部。我们可以做的是给底部 10 像素，或者 0 像素，即省略 `wx.BOTTOM`。 所以如果我们需要不同的值，我们可以添加一些额外的空间。 使用 `Add()` 方法，我们也可以插入组件和空间。 

```python
vbox.Add(hbox5, flag=wx.ALIGN_RIGHT|wx.RIGHT, border=10)
```

我们将两个按钮放在窗口的右侧。要实现这需要做三件事：proportion、align flag 和 `wx.EXPAND` flag。 比例 proportion 必须为 0。当我们调整窗口大小时，我们不应该改变它们的大小。我们不能指定 `wx.EXPAND` 标志。这些按钮仅覆盖已经分配给它们的区域。最后，我们必须指定 `wx.ALIGN_RIGHT` 标志。水平 sizer 从窗口左侧扩展到右侧。所以如果我们指定了 `wx.ALIGN_RIGHT` 标志，那么这些按钮就会放在右侧。

![GoToClass window](/assets/gotoclass.png) 

## wx.GridSizer

`wx.GridSizer` 在二维表格中展示组件。 表格中的每个单元具有相同的大小。 

```python
wx.GridSizer(int rows=1, int cols=0, int vgap=0, int hgap=0)
```

在构造函数中，我们指定表中的行数和列数，纵向和横向的单元格之间的间隔（单位是像素）。

在我们的例子中，我们创建了一个计算器的骨架。

**calculator.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
ZetCode wxPython tutorial

In this example we create a layout
of a calculator with wx.GridSizer.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()


    def InitUI(self):

        menubar = wx.MenuBar()
        fileMenu = wx.Menu()
        menubar.Append(fileMenu, '&File')
        self.SetMenuBar(menubar)

        vbox = wx.BoxSizer(wx.VERTICAL)
        self.display = wx.TextCtrl(self, style=wx.TE_RIGHT)
        vbox.Add(self.display, flag=wx.EXPAND|wx.TOP|wx.BOTTOM, border=4)
        gs = wx.GridSizer(5, 4, 5, 5)

        gs.AddMany( [(wx.Button(self, label='Cls'), 0, wx.EXPAND),
            (wx.Button(self, label='Bck'), 0, wx.EXPAND),
            (wx.StaticText(self), wx.EXPAND),
            (wx.Button(self, label='Close'), 0, wx.EXPAND),
            (wx.Button(self, label='7'), 0, wx.EXPAND),
            (wx.Button(self, label='8'), 0, wx.EXPAND),
            (wx.Button(self, label='9'), 0, wx.EXPAND),
            (wx.Button(self, label='/'), 0, wx.EXPAND),
            (wx.Button(self, label='4'), 0, wx.EXPAND),
            (wx.Button(self, label='5'), 0, wx.EXPAND),
            (wx.Button(self, label='6'), 0, wx.EXPAND),
            (wx.Button(self, label='*'), 0, wx.EXPAND),
            (wx.Button(self, label='1'), 0, wx.EXPAND),
            (wx.Button(self, label='2'), 0, wx.EXPAND),
            (wx.Button(self, label='3'), 0, wx.EXPAND),
            (wx.Button(self, label='-'), 0, wx.EXPAND),
            (wx.Button(self, label='0'), 0, wx.EXPAND),
            (wx.Button(self, label='.'), 0, wx.EXPAND),
            (wx.Button(self, label='='), 0, wx.EXPAND),
            (wx.Button(self, label='+'), 0, wx.EXPAND) ])

        vbox.Add(gs, proportion=1, flag=wx.EXPAND)
        self.SetSizer(vbox)


def main():

    app = wx.App()
    ex = Example(None, title='Calculator')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

注意我们是如何设置在 Bck 和 Close 按钮之间的间隔。 我们只需在其中放置一个空的 `wx.StaticText` 。

在我们的例子中，我们使用了 `AddMany()` 方法。 这是一次添加多个组件的便捷方法。

```python
gs.AddMany( [(wx.Button(self, label='Cls'), 0, wx.EXPAND),
...
```

组件 Widgets 按顺序被放置在表格内。第一行先填充，然后是第二行等 

![Calculator](/assets/calculator.png)Figure: Calculator

## wx.FlexGridSizer

这个 sizer 与 `wx.GridSizer` 类似。它也在一个二维表中的放置组件。它增加了一些灵活性。`wx.GridSizer` 单元格大小相同。`wx.FlexGridSizer` 中的所有单元格在同一行中具有相同的高度。所有单元在一列中具有相同的宽度。但是所有的行和列不需要是同样的高度或宽度。 

```python
wx.FlexGridSizer(int rows=1, int cols=0, int vgap=0, int hgap=0)
```

`rows` 和 `cols` 指定了 sizer 中的行数和列数。 `vgap` 和 `hgap` 在两个方向上的组件之间添加一些空间。

很多时候开发人员必须开发用于数据输入和修改的对话框。 我发现 `wx.FlexGridSizer` 适合这样的任务。 开发人员可以使用此 sizer 轻松设置对话窗口 dialog window。 使用 `wx.GridSizer` 也可以实现，但由于每个单元必须具有相同的大小，所以它看起来不太好。

**review.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example we create review
layout with wx.FlexGridSizer.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()
        self.Show()

    def InitUI(self):

        panel = wx.Panel(self)

        hbox = wx.BoxSizer(wx.HORIZONTAL)

        fgs = wx.FlexGridSizer(3, 2, 9, 25)

        title = wx.StaticText(panel, label="Title")
        author = wx.StaticText(panel, label="Author")
        review = wx.StaticText(panel, label="Review")

        tc1 = wx.TextCtrl(panel)
        tc2 = wx.TextCtrl(panel)
        tc3 = wx.TextCtrl(panel, style=wx.TE_MULTILINE)

        fgs.AddMany([(title), (tc1, 1, wx.EXPAND), (author),
            (tc2, 1, wx.EXPAND), (review, 1, wx.EXPAND), (tc3, 1, wx.EXPAND)])

        fgs.AddGrowableRow(2, 1)
        fgs.AddGrowableCol(1, 1)

        hbox.Add(fgs, proportion=1, flag=wx.ALL|wx.EXPAND, border=15)
        panel.SetSizer(hbox)


def main():

    app = wx.App()
    ex = Example(None, title='Review')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

在上面的代码示例中，我们使用 `FlexGridSizer` 创建了一个 Review 窗口。 

```python
hbox = wx.BoxSizer(wx.HORIZONTAL)
...
hbox.Add(fgs, proportion=1, flag=wx.ALL|wx.EXPAND, border=15)
```

我们创建一个水平 box sizer，为了在组件的表格周围放一些间隔空间（15px）。

```python
fgs.AddMany([(title), (tc1, 1, wx.EXPAND), (author), 
    (tc2, 1, wx.EXPAND), (review, 1, wx.EXPAND), (tc3, 1, wx.EXPAND)])
```

我们使用 `AddMany()` 方法将组件添加到 sizer 中。 `wx.FlexGridSizer` 和 `wx.GridSizer` 共用此方法。

```python
fgs.AddGrowableRow(2, 1)
fgs.AddGrowableCol(1, 1)
```

我们使第三行和第二列可以成长。通过这种方式，我们可以在窗口大小调整时让文本框增长。第一个和第二个文本框在水平方向增长，第三个双向增长。我们必须谨记使用 `wx.EXPAND` 使组件可扩展。 

![Review](/assets/review.png) 

## wx.GridBagSizer

`wx.GridBagSizer` 是 wxPython 中最灵活的 sizer。这种 sizer 不仅适用于 wxPython，我们也可以在其他工具包中找到它。

此 sizer 可以显式定位项目。项目也可以选择跨越多个行或列。`wx.GridBagSizer` 有一个简单的构造函数。

```python
wx.GridBagSizer(integer vgap, integer hgap)
```

垂直和水平 gap：定义所有孩子的间隔（单位为像素）。 我们用 `Add()` 方法将项目添加到网格中。 

```python
Add(self, item, tuple pos, tuple span=wx.DefaultSpan, integer flag=0, 
    integer border=0, userData=None)
```

item：一个插入到网格中的组件。

pos：指定虚拟网格中的位置。左上角的单元格的位置为 (0, 0)。 

span：是一个可选的 spanning 组件的；例如，一个 (3, 2) 的 span，跨越 3 行 2 列的组件。 

flag 和 border：在前面的 `wx.BoxSizer` 中讨论过。

调整窗口大小时，网格中的项目可以更改其大小或保持默认大小。 如果我们想要增长和缩小，我们可以使用以下两种方法： 

```python
AddGrowableRow(integer row)
AddGrowableCol(integer col)
```

## Rename window example

在我们的第一个例子中，我们创建了一个 Rename 窗口。它将有一个 `wx.StaticText`，一个 `wx.TextCtrl` 和两个 `wx.Button` 组件。 

**rename.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example we create a rename layout
with wx.GridBagSizer.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx


class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()

    def InitUI(self):

        panel = wx.Panel(self)
        sizer = wx.GridBagSizer(4, 4)

        text = wx.StaticText(panel, label="Rename To")
        sizer.Add(text, pos=(0, 0), flag=wx.TOP|wx.LEFT|wx.BOTTOM, border=5)

        tc = wx.TextCtrl(panel)
        sizer.Add(tc, pos=(1, 0), span=(1, 5),
            flag=wx.EXPAND|wx.LEFT|wx.RIGHT, border=5)

        buttonOk = wx.Button(panel, label="Ok", size=(90, 28))
        buttonClose = wx.Button(panel, label="Close", size=(90, 28))
        sizer.Add(buttonOk, pos=(3, 3))
        sizer.Add(buttonClose, pos=(3, 4), flag=wx.RIGHT|wx.BOTTOM, border=10)

        sizer.AddGrowableCol(1)
        sizer.AddGrowableRow(2)
        panel.SetSizer(sizer)


def main():

    app = wx.App()
    ex = Example(None, title='Rename')
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

我们必须将窗口看做一个大的网格。 

```python
text = wx.StaticText(panel, label="Rename To")
sizer.Add(text, pos=(0, 0), flag=wx.TOP|wx.LEFT|wx.BOTTOM, border=10)
```

The text "Rename to" goes to the left upper corner. So we specify the (0, 0) position. And we add some space to the bottom, left, and bottom.

文本“重命名”放在左上角，所以我们指定 (0, 0) 的位置。我们在底部，左侧和底部添加一些空间。 

```python
tc = wx.TextCtrl(panel)
sizer.Add(tc, pos=(1, 0), span=(1, 5), 
    flag=wx.EXPAND|wx.LEFT|wx.RIGHT, border=5)
```

`wx.TextCtrl` 进入第二行的开始处 (1, 0)。 请记住，我们从零开始计数。它扩展了 1 行 和 5 列 (1, 5)。我们把5个像素的空间放在左边。 

```python
sizer.Add(buttonOk, pos=(3, 3))
sizer.Add(buttonClose, pos=(3, 4), flag=wx.RIGHT|wx.BOTTOM, border=10)
```

我们把两个按钮放到第四行，第三行留空，所以在 `wx.TextCtrl` 和按钮之间有一些空间。我们把 OK 按钮放到第四列，Close 按钮放在第五列。注意我们将间隔空间应用到一个组件，它会应用到整行。这就是为什么我们不给OK 按钮指定间隔。细心的读者可能注意到我们没有在两个按钮之间指定任何空间。 也就是说，我们没有在右侧 OK 按钮和右侧是 Close 按钮上放置任何空间。 在 `wx.GridBagSizer` 的构造函数中，我们在所有组件之间放置了一些空间。 所以已经有一些空间了。 

```python
sizer.AddGrowableCol(1)
sizer.AddGrowableRow(2)
```

我们必须做的最后一件事是让我们的对话框可调整大小。我们让第二列和第三列可增长。现在我们可以扩大或缩小我们的窗口。尝试评论这两行，看看会发生什么。

![Rename](/assets/rename.png) 

## New class example

在下一个示例中，我们创建一个窗口，该窗口可以在 JDeveloper 中找到。 这是用于给 Java 创建一个新类的窗口。 

**new_class.py**

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ZetCode wxPython tutorial

In this example we create a new class layout
with wx.GridBagSizer.

author: Jan Bodnar
website: www.zetcode.com
last modified: April 2018
"""

import wx

class Example(wx.Frame):

    def __init__(self, parent, title):
        super(Example, self).__init__(parent, title=title)

        self.InitUI()
        self.Centre()

    def InitUI(self):

        panel = wx.Panel(self)

        sizer = wx.GridBagSizer(5, 5)

        text1 = wx.StaticText(panel, label="Java Class")
        sizer.Add(text1, pos=(0, 0), flag=wx.TOP|wx.LEFT|wx.BOTTOM,
            border=15)

        icon = wx.StaticBitmap(panel, bitmap=wx.Bitmap('exec.png'))
        sizer.Add(icon, pos=(0, 4), flag=wx.TOP|wx.RIGHT|wx.ALIGN_RIGHT,
            border=5)

        line = wx.StaticLine(panel)
        sizer.Add(line, pos=(1, 0), span=(1, 5),
            flag=wx.EXPAND|wx.BOTTOM, border=10)

        text2 = wx.StaticText(panel, label="Name")
        sizer.Add(text2, pos=(2, 0), flag=wx.LEFT, border=10)

        tc1 = wx.TextCtrl(panel)
        sizer.Add(tc1, pos=(2, 1), span=(1, 3), flag=wx.TOP|wx.EXPAND)

        text3 = wx.StaticText(panel, label="Package")
        sizer.Add(text3, pos=(3, 0), flag=wx.LEFT|wx.TOP, border=10)

        tc2 = wx.TextCtrl(panel)
        sizer.Add(tc2, pos=(3, 1), span=(1, 3), flag=wx.TOP|wx.EXPAND,
            border=5)

        button1 = wx.Button(panel, label="Browse...")
        sizer.Add(button1, pos=(3, 4), flag=wx.TOP|wx.RIGHT, border=5)

        text4 = wx.StaticText(panel, label="Extends")
        sizer.Add(text4, pos=(4, 0), flag=wx.TOP|wx.LEFT, border=10)

        combo = wx.ComboBox(panel)
        sizer.Add(combo, pos=(4, 1), span=(1, 3),
            flag=wx.TOP|wx.EXPAND, border=5)

        button2 = wx.Button(panel, label="Browse...")
        sizer.Add(button2, pos=(4, 4), flag=wx.TOP|wx.RIGHT, border=5)

        sb = wx.StaticBox(panel, label="Optional Attributes")

        boxsizer = wx.StaticBoxSizer(sb, wx.VERTICAL)
        boxsizer.Add(wx.CheckBox(panel, label="Public"),
            flag=wx.LEFT|wx.TOP, border=5)
        boxsizer.Add(wx.CheckBox(panel, label="Generate Default Constructor"),
            flag=wx.LEFT, border=5)
        boxsizer.Add(wx.CheckBox(panel, label="Generate Main Method"),
            flag=wx.LEFT|wx.BOTTOM, border=5)
        sizer.Add(boxsizer, pos=(5, 0), span=(1, 5),
            flag=wx.EXPAND|wx.TOP|wx.LEFT|wx.RIGHT , border=10)

        button3 = wx.Button(panel, label='Help')
        sizer.Add(button3, pos=(7, 0), flag=wx.LEFT, border=10)

        button4 = wx.Button(panel, label="Ok")
        sizer.Add(button4, pos=(7, 3))

        button5 = wx.Button(panel, label="Cancel")
        sizer.Add(button5, pos=(7, 4), span=(1, 1),
            flag=wx.BOTTOM|wx.RIGHT, border=10)

        sizer.AddGrowableCol(2)

        panel.SetSizer(sizer)
        sizer.Fit(self)
        

def main():

    app = wx.App()
    ex = Example(None, title="Create Java Class")
    ex.Show()
    app.MainLoop()


if __name__ == '__main__':
    main()
```

这是一个更复杂的布局，我们使用 `wx.GridBagSizer` 和 `wx.StaticBoxsizer`。

```python
line = wx.StaticLine(panel)
sizer.Add(line, pos=(1, 0), span=(1, 5), 
    flag=wx.EXPAND|wx.BOTTOM, border=10)
```

这是用于在布局中分隔小组件组的一行。 

```python
icon = wx.StaticBitmap(panel, bitmap=wx.Bitmap('exec.png'))
sizer.Add(icon, pos=(0, 4), flag=wx.TOP|wx.RIGHT|wx.ALIGN_RIGHT, 
    border=5)
```

我们把一个 `wx.StaticBitmap` 放进网格的第一行，我们把它放在行的右侧。 

```python
sb = wx.StaticBox(panel, label="Optional Attributes")
boxsizer = wx.StaticBoxSizer(sb, wx.VERTICAL)
```

`wxStaticBoxSizer` 就像一个普通的 `wx.BoxSizer`，但它在 sizer 周围添加 static box。我们将复选框放入 static box sizer 中。

![New class window](/assets/newclass.png) 

这部分 wxPython 教程专门用于布局管理。 

































